
name: GitLab CI Converter (Group-wide)

on:
  workflow_dispatch: {}

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  discover_projects:
    name: "1) Discover GitLab projects for conversion"
    runs-on: ubuntu-latest
    outputs:
      project_list: ${{ steps.collect.outputs.project_list }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GL_URL: ${{ vars.GL_URL }}
      GL_GROUP: ${{ vars.GL_GROUP }}
      REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}
      GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}
      GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }}
    steps:
      - name: Install jq & curl
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq curl
      - name: Collect & filter projects under GL_GROUP (exclude deletion-scheduled)
        id: collect
        shell: bash
        run: |
          set -euo pipefail
          : "${GL_URL:?GL_URL is required}"
          : "${GL_GROUP:?GL_GROUP is required}"
          GL_API="${GL_URL%/}/api/v4"
          GROUP_ENC=$(jq -rn --arg x "${GL_GROUP}" '$x|@uri')
          REPO_NAME_MODE="${REPO_NAME_MODE:-path}"
          GH_REPO_PREFIX="${GH_REPO_PREFIX:-}"
          SEP="${GH_REPO_SEPARATOR:-"-"}"
          page=1
          filtered=()
          while true; do
            RESP=$(mktemp) ; HDR=$(mktemp)
            curl -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/groups/${GROUP_ENC}/projects?per_page=100&page=${page}&include_subgroups=true" > "${RESP}"
            while read -r proj; do
              path=$(jq -r '.path_with_namespace' <<<"${proj}")
              [[ -z "${path}" ]] && continue
              if [[ "${REPO_NAME_MODE}" == "fullpath" ]]; then
                base="$(echo "${path}" | tr '/' "${SEP}")"
              else
                base="${path##*/}"
              fi
              dest="${GH_REPO_PREFIX}${base}"
              if [[ "${dest}" == deletion_scheduled-* || "${dest}" == *deletion_scheduled-* ]]; then
                echo "Exclude (deletion-scheduled): ${dest} (from GL: ${path})"
              else
                filtered+=("${path}")
              fi
            done < <(jq -c '.[]' "${RESP}")
            next=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')
            [[ -z "${next:-}" || "${next}" == "0" ]] && break
            page="${next}"
          done
          json=$(printf '%s\n' "${filtered[@]:-}" | jq -R . | jq -s -c .)
          echo "project_list=${json}" >> "$GITHUB_OUTPUT"

  repo_migration_commit_sync_all:
    name: "2) Repo Migration · Commit/Refs/LFS mirror (ALL projects)"
    needs: discover_projects
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 4
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_URL: ${{ vars.GL_URL }}
      GH_OWNER: ${{ vars.GH_OWNER }}
      REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}
      GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}
      GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }}
      AUTO_CREATE: ${{ vars.AUTO_CREATE_REPO }}
      INIT_IF_EMPTY_DEST: ${{ vars.INIT_IF_EMPTY_DEST }}
      WORKDIR: /tmp/mirror-work
    steps:
      - name: Install jq, curl, git, git-lfs
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq curl git git-lfs
          git lfs install
      - name: Compute destination repo name
        id: repo
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          MODE="${REPO_NAME_MODE:-path}"
          PREF="${GH_REPO_PREFIX:-}"
          SEP="${GH_REPO_SEPARATOR:-"-"}"
          if [[ "${MODE}" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${SEP}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          GH_REPO="${PREF}${base}"
          echo "gh_repo=${GH_REPO}" >> "$GITHUB_OUTPUT"
      - name: Skip if destination repo is deletion-scheduled
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          if [[ "${GH_REPO}" == deletion_scheduled-* || "${GH_REPO}" == *deletion_scheduled-* ]]; then
            echo "Skipping repo marked for deletion: ${GH_OWNER}/${GH_REPO}"
            exit 0
          fi
      - name: Prepare GitLab API (safe encoding)
        id: glapi
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')
          echo "GL_API=${GL_API}" >> "$GITHUB_ENV"
          echo "GL_ENC=${GL_ENC}" >> "$GITHUB_ENV"
      - name: Check GitLab source branches (non-fatal)
        id: srcbranches
        run: |
          set -euo pipefail
          RESP=$(mktemp)
          if ! curl --fail-with-body -s -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
            "${GL_API}/projects/${GL_ENC}/repository/branches?per_page=1" > "${RESP}"; then
            echo "WARN: Could not list branches for '${{ matrix.project }}' – skipping mirror."
            head -c 300 "${RESP}" || true
            echo "has_branches=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          TYPE=$(jq -r 'type' "${RESP}" 2>/dev/null || echo "unknown")
          if [[ "${TYPE}" != "array" ]]; then
            echo "WARN: Unexpected response type=${TYPE} – skipping mirror."
            head -c 300 "${RESP}" || true
            echo "has_branches=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          COUNT=$(jq 'length' "${RESP}")
          if [[ "${COUNT}" -ge 1 ]]; then
            echo "GitLab source has ${COUNT} branch(es)."
            echo "has_branches=true" >> "$GITHUB_OUTPUT"
          else
            echo "GitLab source has NO branches."
            echo "has_branches=false" >> "$GITHUB_OUTPUT"
          fi
      - name: Ensure GitHub repo exists (create if missing; no deletions)
        if: ${{ env.AUTO_CREATE != 'false' }}
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          REPO_API="https://api.github.com/repos/${GH_OWNER}/${GH_REPO}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_PAT}" "${REPO_API}")
          if [[ "${STATUS}" == "200" ]]; then
            echo "Repo ${GH_OWNER}/${GH_REPO} exists."
          else
            MY_LOGIN=$(curl -s -H "Authorization: Bearer ${GH_PAT}" https://api.github.com/user | jq -r '.login')
            if [[ "${GH_OWNER}" == "${MY_LOGIN}" ]]; then
              CREATE_URL="https://api.github.com/user/repos"
            else
              CREATE_URL="https://api.github.com/orgs/${GH_OWNER}/repos"
            fi
            PAYLOAD=$(jq -n --arg name "${GH_REPO}" '{name:$name, private:true, has_issues:true, has_projects:true, has_wiki:true}')
            RESP=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
              -H "Authorization: Bearer ${GH_PAT}" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/json" \
              -d "${PAYLOAD}" "${CREATE_URL}")
            HTTP=$(echo "${RESP}" | sed -n 's/^HTTP_STATUS://p')
            if [[ "${HTTP}" != "201" ]]; then
              echo "ERROR: Create repo failed (HTTP ${HTTP})"; exit 1
            fi
            echo "Created https://github.com/${GH_OWNER}/${GH_REPO}"
          fi
      - name: Clone GitLab --mirror and push to GitHub (includes tags)
        if: steps.srcbranches.outputs.has_branches == 'true'
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          mkdir -p "${WORKDIR}"
          cd "${WORKDIR}"
          HOST="${GL_URL#*://}"
          SRC_URL="https://oauth2:${GL_TOKEN}@${HOST}/${{ matrix.project }}.git"
          echo "Cloning --mirror from ${GL_URL}/${{ matrix.project }}"
          git clone --mirror "${SRC_URL}" src.git
          cd src.git
          PUSH_URL="https://x-access-token:${GH_PAT}@github.com/${GH_OWNER}/${GH_REPO}.git"
          git remote remove github 2>/dev/null || true
          git remote add github "${PUSH_URL}"
          echo "Pushing --mirror (includes branches & tags) to ${GH_OWNER}/${GH_REPO}..."
          git push --mirror github
          git lfs fetch --all || true
          git lfs push --all github || true
      - name: Verify branches exist in destination after mirror
        if: steps.srcbranches.outputs.has_branches == 'true'
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          RESP=$(mktemp)
          if ! curl --fail-with-body -s -H "Authorization: Bearer ${GH_PAT}" \
            "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/branches?per_page=100" > "${RESP}"; then
            echo "ERROR: Could not list destination branches"; head -c 300 "${RESP}" || true; exit 1
          fi
          TYPE=$(jq -r 'type' "${RESP}" 2>/dev/null || echo "unknown")
          [[ "${TYPE}" == "array" ]] || { echo "ERROR: Destination branch list response not array"; head -c 300 "${RESP}" || true; exit 1; }
          COUNT=$(jq 'length' "${RESP}")
          if [[ "${COUNT}" -lt 1 ]]; then
            echo "ERROR: No branches found in destination after mirror push."; exit 1
          fi
          echo "Destination now has ${COUNT} branch(es)."
      - name: Optionally initialize destination if source is empty
        if: steps.srcbranches.outputs.has_branches != 'true' && env.INIT_IF_EMPTY_DEST == 'true'
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          DEFAULT_BRANCH="main"
          PINFO=$(mktemp)
          if curl --fail-with-body -s -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
            "${GL_API}/projects/${GL_ENC}" > "${PINFO}"; then
            DEFAULT_BRANCH=$(jq -r '.default_branch // "main"' "${PINFO}")
          fi
          echo "Initializing destination with a README on branch '${DEFAULT_BRANCH}'..."
          CONTENT=$(printf '# %s\n\nInitialized because GitLab source contained no branches.\n' "${GH_REPO}" | base64 -w0)
          PUT_RESP=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
            -X PUT -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" -H "Content-Type: application/json" \
            -d "$(jq -n --arg msg "Initialize ${DEFAULT_BRANCH}" --arg content "${CONTENT}" --arg branch "${DEFAULT_BRANCH}" '{message:$msg, content:$content, branch:$branch}')" \
            "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/README.md")
          HTTP=$(echo "${PUT_RESP}" | sed -n 's/^HTTP_STATUS://p')
          [[ "${HTTP}" == "201" || "${HTTP}" == "200" ]] || { echo "ERROR: Failed to initialize repository (HTTP ${HTTP})."; exit 1; }
          PATCH_HTTP=$(curl -s -o /dev/null -w "%{http_code}" \
            -X PATCH -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
            -d "{\"default_branch\":\"${DEFAULT_BRANCH}\"}" \
            "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}")
          [[ "${PATCH_HTTP}" == "200" ]] || echo "WARN: Could not set default_branch (HTTP ${PATCH_HTTP})."
          echo "Destination initialized with README on '${DEFAULT_BRANCH}'."

  repo_migration_label_sync_all:
    name: "4) Repo Migration · Label Sync (ALL projects)"
    needs: [discover_projects]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_URL: ${{ vars.GL_URL }}
      GH_OWNER: ${{ vars.GH_OWNER }}
      REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}
      GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}
      GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }}
    steps:
      - name: Install jq & curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl
      - name: Prepare GitLab API (+ compute GH_REPO)
        id: prep
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')
          echo "GL_API=${GL_API}" >> "$GITHUB_ENV"
          echo "GL_ENC=${GL_ENC}" >> "$GITHUB_ENV"
          MODE="${REPO_NAME_MODE:-path}"
          PREF="${GH_REPO_PREFIX:-}"
          SEP="${GH_REPO_SEPARATOR:-"-"}"
          if [[ "${MODE}" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${SEP}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          GH_REPO="${PREF}${base}"
          echo "gh_repo=${GH_REPO}" >> "$GITHUB_OUTPUT"
      - name: Migrate labels (GitLab → GitHub)
        env:
          GH_REPO: ${{ steps.prep.outputs.gh_repo }}
        run: |
          set -euo pipefail
          page=1
          while true; do
            RESP=$(mktemp) ; HDR=$(mktemp)
            if ! curl --fail-with-body -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/projects/${GL_ENC}/labels?per_page=100&page=${page}" > "${RESP}"; then
              echo "ERROR: GitLab Labels API non-2xx"; cat "${HDR}" || true; head -c 300 "${RESP}" || true; exit 1
            fi
            [[ "$(jq -r 'type' "${RESP}")" == "array" ]] || { echo "WARN: labels response not array"; head -c 300 "${RESP}" || true; break; }
            jq -c '.[]' "${RESP}" | while IFS= read -r lbl; do
              name=$(printf '%s' "${lbl}" | jq -r '.name')
              color=$(printf '%s' "${lbl}" | jq -r '.color' | sed 's/^#//')
              description=$(printf '%s' "${lbl}" | jq -r '.description // empty')
              CREATE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
                -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" -H "Content-Type: application/json" \
                -d "$(jq -n --arg name "${name}" --arg color "${color}" --arg desc "${description}" '{name:$name, color:$color, description:$desc}')" \
                "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/labels")
              ST=$(echo "${CREATE}" | sed -n 's/^HTTP_STATUS://p')
              if [[ "${ST}" != "201" ]]; then
                NAME_ENC=$(jq -rn --arg x "${name}" '$x|@uri')
                curl -s -o /dev/null -w "%{http_code}" -X PATCH \
                  -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" -H "Content-Type: application/json" \
                  -d "$(jq -n --arg new "${name}" --arg color "${color}" --arg desc "${description}" '{new_name:$new, color:$color, description:$desc}')" \
                  "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/labels/${NAME_ENC}" >/dev/null
              fi
              sleep 1
            done
            next=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')
            [[ -z "${next:-}" || "${next}" == "0" ]] && break
            page="${next}"
          done

  repo_migration_milestone_sync_all:
    name: "5) Repo Migration · Milestone Sync (ALL projects)"
    needs: [discover_projects, repo_migration_label_sync_all]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_URL: ${{ vars.GL_URL }}
      GH_OWNER: ${{ vars.GH_OWNER }}
      REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}
      GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}
      GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }}
    steps:
      - name: Install jq & curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl
      - name: Prepare GitLab API (+ compute GH_REPO)
        id: prep
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')
          echo "GL_API=${GL_API}" >> "$GITHUB_ENV"
          echo "GL_ENC=${GL_ENC}" >> "$GITHUB_ENV"
          MODE="${REPO_NAME_MODE:-path}"
          PREF="${GH_REPO_PREFIX:-}"
          SEP="${GH_REPO_SEPARATOR:-"-"}"
          if [[ "${MODE}" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${SEP}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          GH_REPO="${PREF}${base}"
          echo "gh_repo=${GH_REPO}" >> "$GITHUB_OUTPUT"
      - name: Migrate milestones (GitLab → GitHub)
        env:
          GH_REPO: ${{ steps.prep.outputs.gh_repo }}
        run: |
          set -Eeuo pipefail
          trap 'echo "Milestone step failed at line $LINENO"; exit 1' ERR
          GH_LIST=$(curl -s -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/milestones?state=all&per_page=100")
          TITLE_FILE=$(mktemp); printf '{}' > "${TITLE_FILE}"
          printf '%s' "${GH_LIST}" | jq -c 'map({ (.title): .number }) | add // {}' > "${TITLE_FILE}"
          GLID_FILE=$(mktemp); printf '{}' > "${GLID_FILE}"
          printf '%s' "${GH_LIST}" | jq -c '
            map(
              select(.description) as $m
              | (.description | capture("GLMID:(?<id>[0-9]+)")? // null) as $cap
              | if $cap != null then { ($cap.id): $m.number } else {} end
            )
            | add // {}
          ' > "${GLID_FILE}"
          page=1
          while true; do
            RESP=$(mktemp) ; HDR=$(mktemp)
            if ! curl --fail-with-body -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" -G \
              --data-urlencode "per_page=100" --data-urlencode "page=${page}" --data-urlencode "include_ancestors=true" --data-urlencode "state=all" \
              "${GL_API}/projects/${GL_ENC}/milestones" > "${RESP}"; then
              echo "ERROR: GitLab Milestones API non-2xx"; cat "${HDR}" || true; head -c 300 "${RESP}" || true; exit 1
            fi
            [[ "$(jq -r 'type' "${RESP}")" == "array" ]] || { echo "WARN: milestones response not array"; head -c 300 "${RESP}" || true; break; }
            jq -c '.[]' "${RESP}" | while IFS= read -r ms; do
              gl_id=$(jq -r '.id' <<< "${ms}")
              title=$(jq -r '.title' <<< "${ms}")
              description=$(jq -r '.description // ""' <<< "${ms}")
              raw_due=$(jq -r '.due_date // ""' <<< "${ms}")
              due_on=""; [[ -n "${raw_due}" && "${raw_due}" != "null" ]] && due_on="${raw_due}T23:59:59Z"
              desired_title="${title}"; token="GLMID:${gl_id}"; desired_desc="${token}\n\n${description}"
              number=$(jq -r --arg id "${gl_id}" '.[$id] // ""' "${GLID_FILE}")
              gl_state=$(jq -r '.state // "active"' <<< "${ms}")
              gh_state="open"; [[ "${gl_state}" == "closed" ]] && gh_state="closed"
              if [[ -n "${number}" && "${number}" != "null" ]]; then
                payload=$(jq -n --arg title "${desired_title}" --arg desc "${desired_desc}" --arg state "${gh_state}" --arg due "${due_on}" '
                  { title:$title, description:$desc, state:$state } + ( if $due != "" then { due_on:$due } else {} end )
                ')
                st=$(curl -s -o /dev/null -w "%{http_code}" -X PATCH \
                  -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" -H "Content-Type: application/json" \
                  -d "${payload}" \
                  "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/milestones/${number}")
                echo "Update '${desired_title}' (#${number}) → HTTP ${st}"
              else
                title_in_use=$(jq -r --arg t "${desired_title}" '.[$t] // ""' "${TITLE_FILE}")
                create_title="${desired_title}"; [[ -n "${title_in_use}" && "${title_in_use}" != "null" ]] && create_title="${desired_title} (GLMID:${gl_id})"
                payload=$(jq -n --arg title "${create_title}" --arg desc "${desired_desc}" --arg state "${gh_state}" --arg due "${due_on}" '
                  { title:$title, description:$desc, state:$state } + ( if $due != "" then { due_on:$due } else {} end )
                ')
                resp=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
                  -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" -H "Content-Type: application/json" \
                  -d "${payload}" \
                  "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/milestones")
                http=$(echo "${resp}" | sed -n 's/^HTTP_STATUS://p')
                echo "Create '${create_title}' → HTTP ${http}"
              fi
              sleep 0.4
            done
            next=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')
            [[ -z "${next:-}" || "${next}" == "0" ]] && break
            page="${next}"
          done

  repo_migration_issue_sync_all:
    name: "6) Repo Migration · Issue Sync (ALL projects)"
    needs: [discover_projects, repo_migration_label_sync_all, repo_migration_milestone_sync_all]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 4
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_URL: ${{ vars.GL_URL }}
      GH_OWNER: ${{ vars.GH_OWNER }}
      REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}
      GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}
      GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }}
    steps:
      - name: Install jq & curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl
      - name: Prepare GitLab API (+ compute GH_REPO)
        id: prep
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')
          echo "GL_API=${GL_API}" >> "$GITHUB_ENV"
          echo "GL_ENC=${GL_ENC}" >> "$GITHUB_ENV"
          MODE="${REPO_NAME_MODE:-path}"
          PREF="${GH_REPO_PREFIX:-}"
          SEP="${GH_REPO_SEPARATOR:-"-"}"
          if [[ "${MODE}" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${SEP}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          GH_REPO="${PREF}${base}"
          echo "gh_repo=${GH_REPO}" >> "$GITHUB_OUTPUT"
      - name: Preload GH milestones (GLMID → number; title → number fallback)
        id: msmap
        env:
          GH_REPO: ${{ steps.prep.outputs.gh_repo }}
        run: |
          set -euo pipefail
          GH_LIST=$(curl -s -H "Authorization: Bearer ${GH_PAT}" \
            "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/milestones?state=all&per_page=100")
          GLID_MAP=$(printf '%s' "${GH_LIST}" | jq -c '
            map(
              select(.description) as $m
              | (.description | capture("GLMID:(?<id>[0-9]+)")? // null) as $cap
              | if $cap != null then { ($cap.id): $m.number } else {} end
            ) | add // {}
          ')
          TITLE_MAP=$(printf '%s' "${GH_LIST}" | jq -c 'map({ (.title): .number }) | add // {}')
          echo "glid_map=${GLID_MAP}" >> "$GITHUB_OUTPUT"
          echo "title_map=${TITLE_MAP}" >> "$GITHUB_OUTPUT"
      - name: Import issues (titles, body, labels, milestone, state, comments)
        env:
          GH_REPO: ${{ steps.prep.outputs.gh_repo }}
          GLID_MAP: ${{ steps.msmap.outputs.glid_map }}
          TITLE_MAP: ${{ steps.msmap.outputs.title_map }}
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          page=1
          while true; do
            RESP=$(mktemp) ; HDR=$(mktemp)
            if ! curl --fail-with-body -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" -G \
              --data-urlencode "scope=all" --data-urlencode "per_page=100" --data-urlencode "page=${page}" \
              "${GL_API}/projects/${GL_ENC}/issues" > "${RESP}"; then
              echo "ERROR: GitLab Issues API non-2xx"; head -c 300 "${RESP}" || true; exit 1
            fi
            [[ "$(jq -r 'type' "${RESP}")" == "array" ]] || { echo "WARN: issues response not array"; break; }
            jq -c '.[]' "${RESP}" | while IFS= read -r iss; do
              title=$(printf '%s' "${iss}" | jq -r '.title')
              body=$(printf '%s' "${iss}" | jq -r '.description // ""')
              state=$(printf '%s' "${iss}" | jq -r '.state')
              labels=$(printf '%s' "${iss}" | jq -c '.labels // []')
              ms_title=$(printf '%s' "${iss}" | jq -r '.milestone.title // ""')
              ms_id=$(printf '%s' "${iss}" | jq -r '.milestone.id // ""')
              author=$(printf '%s' "${iss}" | jq -r '.author.username // "unknown"')
              iid=$(printf '%s' "${iss}" | jq -r '.iid')
              confidential=$(printf '%s' "${iss}" | jq -r '.confidential')
              gl_url="${GL_URL%/}/${GL_PROJECT}/-/issues/${iid}"
              gh_body="**Imported from GitLab by @${author}**\n\n${body}\n\n---\n_Source_: ${gl_url}"
              ms_num=$(jq -r --arg id "${ms_id}" --arg t "${ms_title}" --argjson glmap "${GLID_MAP}" --argjson tlmap "${TITLE_MAP}" '
                if $glmap[$id] then $glmap[$id] else ( if $tlmap[$t] then $tlmap[$t] else empty end ) end
              ')
              payload=$(jq -n --arg title "${title}" --arg body "${gh_body}" --argjson labels "${labels}" --arg marker "imported:gitlab" --argjson msnum "${ms_num:-null}" '
                {title:$title, body:$body, labels:([ $marker ] + ($labels // []))} + ( if $msnum != null and ($msnum|type) == "number" then {milestone:$msnum} else {} end )
              ')
              CREATE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" -H "Content-Type: application/json" \
                -d "${payload}" "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/issues")
              http=$(echo "${CREATE}" | sed -n 's/^HTTP_STATUS://p')
              num=$(echo "${CREATE}" | sed '/^HTTP_STATUS:/d' | jq -r '.number // empty')
              echo "Issue create status=${http} number=${num}"
              if [[ -n "${num}" ]]; then
                cpage=1
                while true; do
                  CRESP=$(mktemp) ; CHDR=$(mktemp)
                  if ! curl --fail-with-body -s -D "${CHDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" -G \
                    --data-urlencode "activity_filter=only_comments" --data-urlencode "per_page=100" --data-urlencode "page=${cpage}" \
                    "${GL_API}/projects/${GL_ENC}/issues/${iid}/notes" > "${CRESP}"; then
                    break
                  fi
                  [[ "$(jq -r 'type' "${CRESP}")" == "array" ]] || break
                  jq -c '.[]' "${CRESP}" | while IFS= read -r note; do
                    nbody=$(printf '%s' "${note}" | jq -r '.body // ""')
                    nauth=$(printf '%s' "${note}" | jq -r '.author.username // "unknown"')
                    curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
                      -d "$(jq -n --arg b "**@${nauth} (from GitLab)**\n\n${nbody}" '{body:$b}')" \
                      "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/issues/${num}/comments" >/dev/null
                    sleep 0.4
                  done
                  nnext=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${CHDR}" | tr -d '\r')
                  [[ -z "${nnext:-}" || "${nnext}" == "0" ]] && break
                  cpage="${nnext}"
                done
                if [[ "${state}" == "closed" ]]; then
                  curl -s -o /dev/null -w "%{http_code}" -X PATCH -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" -d '{"state":"closed"}' \
                    "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/issues/${num}" >/dev/null
                fi
                if [[ "${confidential}" == "true" ]]; then
                  curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
                    -d '["confidential"]' \
                    "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/issues/${num}/labels" >/dev/null
                fi
              fi
              sleep 0.3
            done
            next=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')
            [[ -z "${next:-}" || "${next}" == "0" ]] && break
            page="${next}"
          done

  repo_migration_wiki_sync_all:
    name: "7) Repo Migration · Wiki Sync (ALL projects)"
    needs: [discover_projects, repo_migration_commit_sync_all]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_URL: ${{ vars.GL_URL }}
      GH_OWNER: ${{ vars.GH_OWNER }}
      REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}
      GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}
      GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }}
      AUTO_CREATE: ${{ vars.AUTO_CREATE_REPO }}
      WORKDIR: /tmp/wiki-work
    steps:
      - name: Install git & jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y git jq
      - name: Compute destination repo name
        id: repo
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          MODE="${REPO_NAME_MODE:-path}"
          PREF="${GH_REPO_PREFIX:-}"
          SEP="${GH_REPO_SEPARATOR:-"-"}"
          if [[ "${MODE}" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${SEP}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          GH_REPO="${PREF}${base}"
          echo "gh_repo=${GH_REPO}" >> "$GITHUB_OUTPUT"
      - name: Create GitHub repo if missing
        if: env.AUTO_CREATE != 'false'
        shell: bash
        run: |
          set -euo pipefail
          REPO_API="https://api.github.com/repos/${GH_OWNER}/${GH_REPO}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_PAT}" "${REPO_API}")
          if [[ "${STATUS}" == "200" ]]; then
            echo "Repo already exists."
          else
            MY_LOGIN=$(curl -s -H "Authorization: Bearer ${GH_PAT}" https://api.github.com/user | jq -r '.login')
            CREATE_URL="https://api.github.com/orgs/${GH_OWNER}/repos"
            [[ "${GH_OWNER}" == "${MY_LOGIN}" ]] && CREATE_URL="https://api.github.com/user/repos"
            PAYLOAD=$(jq -n --arg name "${GH_REPO}" '{name:$name, private:true, has_issues:true, has_projects:true, has_wiki:true}')
            RESP=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -H "Authorization: Bearer ${GH_PAT}" -H "Content-Type: application/json" -d "${PAYLOAD}" "${CREATE_URL}")
            HTTP=$(echo "${RESP}" | sed -n 's/^HTTP_STATUS://p')
            [[ "${HTTP}" == "201" ]] || { echo "Failed to create repo (HTTP ${HTTP})."; exit 1; }
          fi
          echo "GH repo ready: https://github.com/${GH_OWNER}/${GH_REPO}"
      - name: Mirror GitLab wiki → GitHub wiki (skip if dest wiki not initialized)
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          mkdir -p "${WORKDIR}" && cd "${WORKDIR}"
          HOST="${GL_URL#*://}"
          SRC_WIKI_URL="https://oauth2:${GL_TOKEN}@${HOST}/${{ matrix.project }}.wiki.git"
          DEST_WIKI_URL="https://x-access-token:${GH_PAT}@github.com/${GH_OWNER}/${GH_REPO}.wiki.git"
          if ! git ls-remote "${SRC_WIKI_URL}" &>/dev/null; then
            echo "No GitLab wiki found for ${{ matrix.project }} — skipping."; exit 0
          fi
          if ! git ls-remote "${DEST_WIKI_URL}" &>/dev/null; then
            echo "::warning::GitHub wiki for ${GH_OWNER}/${GH_REPO} is not initialized yet."
            echo "Open https://github.com/${GH_OWNER}/${GH_REPO}/wiki and click 'Create the first page' (Home)."
            exit 0
          fi
          git clone --mirror "${SRC_WIKI_URL}" src.wiki.git
          cd src.wiki.git
          git remote remove github 2>/dev/null || true
          git remote add github "${DEST_WIKI_URL}"
          echo "Pushing wiki mirror to ${GH_OWNER}/${GH_REPO}.wiki..."
          git push --mirror github

  ci_migration_migrate_all:
    name: "8) ${{ matrix.project }} · GitLab CI → Actions (single PR; preserve filenames)"
    needs: [discover_projects, repo_migration_commit_sync_all]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    permissions:
      contents: write
      pull-requests: write
    env:
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GL_URL: ${{ vars.GL_URL }}
      GH_OWNER: ${{ vars.GH_OWNER }}
      REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}
      GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}
      GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }}
    steps:
      - name: Ensure GitHub CLI & Docker
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y gnupg software-properties-common jq curl git
          if ! command -v gh >/dev/null 2>&1; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
            sudo apt-get update -y
            sudo apt-get install -y gh
          fi
          if ! command -v docker >/dev/null 2>&1; then
            sudo apt-get install -y docker.io
            sudo systemctl enable --now docker
          fi
          docker --version
          gh --version
      - name: Authenticate gh
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          set -euo pipefail
          echo "${GH_PAT}" | gh auth login --with-token --hostname github.com
          gh auth status
      - name: Install / update Actions Importer extension
        run: |
          set -euo pipefail
          gh extension install github/gh-actions-importer || true
          gh actions-importer update || true
          gh actions-importer -h
      - name: Compute destination repo name
        id: repo
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          MODE="${REPO_NAME_MODE:-path}"
          SEP="${GH_REPO_SEPARATOR:-"-"}"
          PREFIX="${GH_REPO_PREFIX:-""}"
          if [[ "${MODE}" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${SEP}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          GH_REPO="${PREFIX}${base}"
          echo "gh_repo=${GH_REPO}" >> "$GITHUB_OUTPUT"
      - name: Configure importer via .env.local
        run: |
          set -euo pipefail
          cat > .env.local <<EOF
          GITHUB_ACCESS_TOKEN=${GH_PAT}
          GITHUB_INSTANCE_URL=https://github.com
          GITLAB_ACCESS_TOKEN=${GL_TOKEN}
          GITLAB_INSTANCE_URL=${GL_URL}
          EOF
      - name: Discover & download CI YAMLs
        id: files
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')
          DEFAULT_BRANCH="$(curl -s -H "PRIVATE-TOKEN: ${GL_TOKEN}" "${GL_API}/projects/${GL_ENC}" | jq -r '.default_branch // "main"')"
          files=()
          next_page="1"
          while [[ -n "${next_page}" && "${next_page}" != "0" ]]; do
            RESP=$(mktemp); HDR=$(mktemp)
            curl -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/projects/${GL_ENC}/repository/tree?ref=${DEFAULT_BRANCH}&recursive=true&per_page=100&page=${next_page}" > "${RESP}"
            while read -r item; do
              t=$(jq -r '.type' <<<"${item}")
              [[ "${t}" == "blob" ]] || continue
              p=$(jq -r '.path' <<<"${item}")
              n=$(jq -r '.name' <<<"${item}")
              if [[ "${n}" =~ ^\.gitlab.*\.(yml|yaml)$ || "${p}" =~ \/\.gitlab\/.*\.(yml|yaml)$ || "${p}" == ".gitlab-ci.yml" ]]; then
                files+=("${p}")
              fi
            done < <(jq -c '.[]' "${RESP}")
            next_page=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')
            [[ -z "${next_page}" ]] && next_page="0"
          done
          if [[ "${#files[@]}" -eq 0 ]]; then
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "list=[]" >> "$GITHUB_OUTPUT"
            echo "::notice::${GL_PROJECT}: No .gitlab* CI files found; skipping migration."
            exit 0
          else
            json=$(printf '%s\n' "${files[@]}" | jq -R . | jq -s -c .)
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "list=${json}" >> "$GITHUB_OUTPUT"
          fi
          mapfile -t files < <(jq -r '.[]' <<< "${json}")
          for f in "${files[@]}"; do
            enc=$(jq -rn --arg x "${f}" '$x|@uri')
            mkdir -p "$(dirname "${f}")"
            curl --fail -s -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/projects/${GL_ENC}/repository/files/${enc}/raw?ref=${DEFAULT_BRANCH}" -o "${f}"
            test -s "${f}"
          done
      - name: Convert ALL CI files to staging (dry-run)
        if: steps.files.outputs.found == 'true'
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          mkdir -p "tmp/converted/${GH_REPO}"
          mapfile -t files < <(jq -r '.[]' <<< '${{ steps.files.outputs.list }}')
          for f in "${files[@]}"; do
            out_dir="tmp/converted/${GH_REPO}/$(echo "${f}" | tr '/:' '_')"
            mkdir -p "${out_dir}"
            gh actions-importer dry-run gitlab \
              --namespace "${{ vars.GL_GROUP || matrix.project }}" \
              --project "${{ matrix.project }}" \
              --output-dir "${out_dir}" \
              --source-file-path "/data/${f}"
          done
      - name: Stage converted workflows (single PR head; preserve filenames)
        id: stage_single
        if: steps.files.outputs.found == 'true'
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
          GH_OWNER: ${{ env.GH_OWNER }}
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          set -euo pipefail
          git config --global user.name "actions-bot"
          git config --global user.email "actions-bot@users.noreply.github.com"
          rm -rf repo && mkdir repo
          git -C repo init
          git -C repo remote add origin "https://x-access-token:${GH_PAT}@github.com/${GH_OWNER}/${GH_REPO}.git"
          git -C repo fetch origin --prune --tags
          API="https://api.github.com/repos/${GH_OWNER}/${GH_REPO}"
          DEFAULT=$(curl -s -H "Authorization: Bearer ${GH_PAT}" "${API}" | jq -r '.default_branch // empty')
          BR_LIST_JSON="$(curl -s -H "Authorization: Bearer ${GH_PAT}" "${API}/branches?per_page=100")"
          FIRST_BRANCH="$(jq -r '.[0].name // empty' <<<"${BR_LIST_JSON}")"
          BASE="${DEFAULT:-${FIRST_BRANCH}}"
          [[ -n "${BASE}" ]] || { echo "ERROR: No branches found in destination; mirror push may have failed." >&2; exit 1; }
          HEAD="ci-migration/all-gitlab-ci-files"
          git -C repo checkout -B "${HEAD}" "origin/${BASE}"
          rm -rf repo/.github/workflows && mkdir -p repo/.github/workflows
          declare -A used=()
          mapfile -t SRC_FILES < <(jq -r '.[]' <<< '${{ steps.files.outputs.list }}')
          for f in "${SRC_FILES[@]}"; do
            SRC_DIR="tmp/converted/${GH_REPO}/$(echo "${f}" | tr '/:' '_')"
            SRC_YAML="$(find "${SRC_DIR}/" -type f -path "*/.github/workflows/*" \( -name '*.yml' -o -name '*.yaml' \) | head -n1)"
            [[ -n "${SRC_YAML:-}" && -s "${SRC_YAML}" ]] || { echo "ERROR: No workflow YAML produced for '${f}'." >&2; exit 1; }
            base="$(basename "${f}")"
            dest="repo/.github/workflows/${base}"
            if [[ -n "${used[$(basename "${dest}")]:-}" ]]; then
              suffix="$(echo "${f%/*}" | tr '/.' '-' | sed 's/^-//;s/-$//;s/[^A-Za-z0-9-]//g')"
              [[ -z "${suffix}" ]] && suffix="$(echo -n "${f}" | sha1sum | cut -c1-6)"
              ext="${base##*.}"; name="${base%.*}"
              dest="repo/.github/workflows/${name}-${suffix}.${ext}"
              if [[ -n "${used[$(basename "${dest}")]:-}" ]]; then
                short="$(echo -n "${f}" | sha1sum | cut -c1-6)"
                dest="repo/.github/workflows/${name}-${short}.${ext}"
              fi
            fi
            used["$(basename "${dest}")"]=1
            cp -f "${SRC_YAML}" "${dest}"
          done
          git -C repo add .github/workflows
          git -C repo commit -m "GitLab CI → GitHub Actions: add converted workflows (preserve filenames)" || true
          git -C repo push -u origin "${HEAD}"
          echo "base=${BASE}" >> "$GITHUB_OUTPUT"
          echo "head=${HEAD}" >> "$GITHUB_OUTPUT"
      - name: Open pull request (ONE per repo)
        if: steps.files.outputs.found == 'true'
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
          GH_OWNER: ${{ env.GH_OWNER }}
        run: |
          set -euo pipefail
          BASE='${{ steps.stage_single.outputs.base }}'
          HEAD='${{ steps.stage_single.outputs.head }}'
          EXISTING="$(gh pr list --repo "${GH_OWNER}/${GH_REPO}" --head "${HEAD}" --json url --jq '.[0].url')"
          if [[ -n "${EXISTING:-}" ]]; then
            echo "::notice::PR already exists for head '${HEAD}': ${EXISTING}"
            exit 0
          fi
          TITLE="GitLab CI → Actions: single PR (all converted files) to '${BASE}'"
          BODY="This PR migrates all discovered \`.gitlab*\` CI files into GitHub Actions workflows (filenames preserved). Review for manual follow‑ups (secrets, runners, environments, rulesets)."
          gh pr create --repo "${GH_OWNER}/${GH_REPO}" --base "${BASE}" --head "${HEAD}" --title "${TITLE}" --body "${BODY}"
