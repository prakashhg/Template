
name: "GitLab → GitHub: Container & Package migration"

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Container mirror dry-run (don't copy images)"
        type: boolean
        default: false

permissions:
  contents: read
  packages: write  # needed when pushing to GHCR with GITHUB_TOKEN

env:
  # ---- GitLab ----
  GL_URL: ${{ vars.GL_URL }}                 # e.g. https://gitlab.com or https://gitlab.example.com
  GL_GROUP: ${{ vars.GL_GROUP }}             # group/subgroup
  GL_REGISTRY_HOST: ${{ vars.GL_REGISTRY_HOST }} # e.g. registry.gitlab.com or your registry host
  # ---- Naming / structure preservation ----
  REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}     # "path" or "fullpath"
  GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}     # optional prefix for GHCR repo/image names
  GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }} # replacement for '/'
  # ---- GH owner for GHCR path ----
  GH_OWNER: ${{ vars.GH_OWNER }}

jobs:
  # 0) Bugfix reference — adjust your CI discovery steps:
  #    Replace the two lines below in your existing workflow steps that list .gitlab* files:
  #      OLD: [[ "$t" == "blob" ]] && continue
  #      NEW: [[ "$t" != "blob" ]] && continue

  # 1) Discover GitLab projects under GL_GROUP (includes subgroups; excludes deletion-scheduled)
  discover_projects:
    name: "Discover GitLab projects for conversion"
    runs-on: ubuntu-latest
    outputs:
      project_list: ${{ steps.collect.outputs.project_list }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
    steps:
      - name: Install jq & curl
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Collect & filter projects under GL_GROUP (exclude deletion-scheduled)
        id: collect
        shell: bash
        run: |
          set -euo pipefail
          : "${GL_URL:?GL_URL required}"; : "${GL_GROUP:?GL_GROUP required}"
          GL_API="${GL_URL%/}/api/v4"
          GROUP_ENC="$(jq -rn --arg x "${GL_GROUP}" '$x|@uri')"
          REPO_NAME_MODE="${REPO_NAME_MODE:-path}"
          GH_REPO_PREFIX="${GH_REPO_PREFIX:-}"
          SEP="${GH_REPO_SEPARATOR:-"-"}"

          page=1
          filtered=()
          while true; do
            RESP="$(mktemp)"; HDR="$(mktemp)"
            curl -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/groups/${GROUP_ENC}/projects?per_page=100&page=${page}&include_subgroups=true" > "${RESP}"

            while read -r proj; do
              path="$(jq -r '.path_with_namespace' <<<"${proj}")"
              [[ -z "${path}" ]] && continue
              if [[ "${REPO_NAME_MODE}" == "fullpath" ]]; then
                base="$(echo "${path}" | tr '/' "${SEP}")"
              else
                base="${path##*/}"
              fi
              dest="${GH_REPO_PREFIX}${base}"
              if [[ "${dest}" == deletion_scheduled-* || "${dest}" == *deletion_scheduled-* ]]; then
                echo "Exclude (deletion-scheduled): ${dest} (from GL: ${path})"
              else
                filtered+=("${path}")
              fi
            done < <(jq -c '.[]' "${RESP}")

            next="$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')"
            [[ -z "${next:-}" || "${next}" == "0" ]] && break
            page="${next}"
          done

          json="$(printf '%s\n' "${filtered[@]:-}" | jq -R . | jq -s -c .)"
          echo "project_list=${json}" >> "${GITHUB_OUTPUT}"

  # 2) Container Registry · Mirror images GitLab → GHCR (ALL projects)
  container_registry_mirror_all:
    name: "Container Registry · Mirror GitLab images → GHCR (ALL projects)"
    needs: [discover_projects]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    env:
      # GitLab side
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GL_REGISTRY_USER: ${{ secrets.GL_REGISTRY_USER }}       # user or deploy-token with read_registry
      GL_REGISTRY_PASSWORD: ${{ secrets.GL_REGISTRY_PASSWORD }}
      # GH side
      GHCR_PAT: ${{ secrets.GHCR_PAT }}                       # optional PAT classic with write:packages
      CR_DRY_RUN: ${{ github.event.inputs.dry_run }}
    steps:
      - name: Install jq & skopeo
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq skopeo

      - name: Compute GHCR image namespace (preserve structure)
        id: ns
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          MODE="${REPO_NAME_MODE:-path}"
          SEP="${GH_REPO_SEPARATOR:-"-"}"
          PREF="${GH_REPO_PREFIX:-""}"
          if [[ "$MODE" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${SEP}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          echo "image_repo_base=${PREF}${base}" >> "$GITHUB_OUTPUT"

      - name: Login to GHCR with GITHUB_TOKEN (repo-scoped)
        if: ${{ env.GHCR_PAT == '' }}
        run: |
          set -euo pipefail
          echo "${{ secrets.GITHUB_TOKEN }}" | skopeo login ghcr.io \
            --username "${{ github.actor }}" --password-stdin

      - name: Login to GHCR with PAT classic (org-scoped or cross-repo)
        if: ${{ env.GHCR_PAT != '' }}
        run: |
          set -euo pipefail
          echo "${GHCR_PAT}" | skopeo login ghcr.io \
            --username "${{ github.actor }}" --password-stdin

      - name: Login to GitLab Container Registry
        run: |
          set -euo pipefail
          echo "${GL_REGISTRY_PASSWORD}" | skopeo login "${GL_REGISTRY_HOST}" \
            --username "${GL_REGISTRY_USER}" --password-stdin

      - name: Discover registry repositories in source
        id: repos
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC="$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')"
          page=1
          repos_json="[]"
          while true; do
            RESP="$(mktemp)"; HDR="$(mktemp)"
            curl -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/projects/${GL_ENC}/registry/repositories?per_page=100&page=${page}" > "${RESP}" || true

            if [[ "$(jq -r 'type' "${RESP}")" != "array" ]]; then
              break
            fi
            repos_json="$(jq -n \
              --argjson acc "${repos_json}" \
              --argjson arr "$(cat "${RESP}")" \
              '$acc + $arr')"

            next="$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')"
            [[ -z "${next:-}" || "${next}" == "0" ]] && break
            page="${next}"
          done
          echo "repo_list=${repos_json}" >> "$GITHUB_OUTPUT"
          echo "gl_enc=${GL_ENC}" >> "$GITHUB_OUTPUT"

      - name: Mirror each image:tag to GHCR (multi-arch; preserve digest; no deletions)
        env:
          GH_IMAGE_BASE: ${{ steps.ns.outputs.image_repo_base }}
          GL_ENC: ${{ steps.repos.outputs.gl_enc }}
        run: |
          set -euo pipefail
          repos_json='${{ steps.repos.outputs.repo_list }}'
          if [[ -z "${repos_json}" || "${repos_json}" == "[]" ]]; then
            echo "::notice::No container repositories for ${{ matrix.project }}"; exit 0
          fi

          mapfile -t repos < <(jq -c '.[]' <<<"${repos_json}")
          for r in "${repos[@]}"; do
            rid="$(jq -r '.id' <<<"${r}")"
            path="$(jq -r '.path' <<<"${r}")"     # e.g. group/project[/subimage]
            # List tags for this repo
            tp=1
            while true; do
              R="$(mktemp)"; H="$(mktemp)"
              curl -s -D "$H" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
                "${GL_URL%/}/api/v4/projects/${GL_ENC}/registry/repositories/${rid}/tags?per_page=100&page=${tp}" > "$R" || true
              [[ "$(jq -r 'type' "$R")" != "array" ]] && break

              jq -r '.[].name' "$R" | while read -r tag; do
                src="docker://${GL_REGISTRY_HOST}/${path}:${tag}"
                dst="docker://ghcr.io/${GH_OWNER}/${GH_IMAGE_BASE}:${tag}"
                if [[ "${CR_DRY_RUN:-false}" == "true" ]]; then
                  echo "DRY-RUN: skopeo copy --all --preserve-digests ${src} ${dst}"
                else
                  skopeo copy --all --preserve-digests \
                    --src-tls-verify=true --dest-tls-verify=true \
                    "${src}" "${dst}"
                fi
              done

              n="$(awk -F': ' '/^X-Next-Page:/ {print $2}' "$H" | tr -d '\r')"
              [[ -z "${n:-}" || "${n}" == "0" ]] && break
              tp="$n"
            done
          done

  # 3) Package Registry · Discovery plan (ALL projects)
  package_registry_discovery_all:
    name: "Package Registry · Discovery Plan (ALL projects)"
    needs: [discover_projects]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 5
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    steps:
      - name: Install jq & curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Enumerate packages in project (type/name/version)
        id: pkgs
        env:
          GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
          GL_URL: ${{ env.GL_URL }}
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC="$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')"
          page=1
          tmp="$(mktemp)"
          : > "$tmp"
          while true; do
            RESP="$(mktemp)"; HDR="$(mktemp)"
            curl -s -D "$HDR" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/projects/${GL_ENC}/packages?per_page=100&page=${page}" > "$RESP" || true
            [[ "$(jq -r 'type' "$RESP")" != "array" ]] && break
            jq -c '.[] | {id, name, version, package_type, _links}' "$RESP" >>"$tmp"
            next="$(awk -F': ' '/^X-Next-Page:/ {print $2}' "$HDR" | tr -d '\r')"
            [[ -z "${next:-}" || "${next}" == "0" ]] && break
            page="${next}"
          done
          echo "list=$(jq -s -c '.' "$tmp")" >> "$GITHUB_OUTPUT"

      - name: Upload discovery as artifact
        uses: actions/upload-artifact@v4
        with:
          name: "package-plan-${{ matrix.project##*/ }}"
          path: ${{ steps.pkgs.outputs.list }}
          if-no-files-found: warn
