
  package_registry_migration_ghcr_all:
    name: "2) Container images (GitLab → GHCR) — ALL projects"
    needs: [discover_projects]
    if: needs.discover_projects.outputs.project_list != '[]'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    env:
      DRY_RUN: ${{ github.event.inputs.dry_run }}
    steps:
      - name: Install jq, curl, skopeo
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq curl skopeo

      - name: Compute GH hosts (GHES-aware)
        id: hosts
        shell: bash
        env:
          GITHUB_SERVER_URL: ${{ github.server_url }}
        run: |
          set -euo pipefail
          srv="${GITHUB_SERVER_URL#*://}"; srv="${srv%%/*}"
          if [[ "${srv}" == "github.com" ]]; then
            echo "ghcr_host=ghcr.io" >> "$GITHUB_OUTPUT"
          else
            echo "ghcr_host=ghcr.${srv}" >> "$GITHUB_OUTPUT"
          fi

      - name: Compute destination repo name
        id: repo
        shell: bash
        env:
          GL_PROJECT: ${{ matrix.project }}
          REPO_NAME_MODE: ${{ env.REPO_NAME_MODE }}
          GH_REPO_PREFIX: ${{ env.GH_REPO_PREFIX }}
          GH_REPO_SEPARATOR: ${{ env.GH_REPO_SEPARATOR }}
        run: |
          set -euo pipefail
          MODE="${REPO_NAME_MODE:-path}"
          SEP="${GH_REPO_SEPARATOR:--}"
          PREF="${GH_REPO_PREFIX:-}"
          if [[ "${MODE}" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${SEP}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          echo "gh_repo=${PREF}${base}" >> "$GITHUB_OUTPUT"

      - name: Prepare APIs & identities
        id: ids
        shell: bash
        env:
          GL_URL: ${{ env.GL_URL }}
          GL_GROUP: ${{ env.GL_GROUP }}
          GL_PROJECT: ${{ matrix.project }}
          GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
          GL_REGISTRY: ${{ env.GL_REGISTRY }}
          CURL_FLAGS: ${{ env.CURL_FLAGS }}
          GHCR_USER: ${{ env.GHCR_USER }}
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC="$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')"
          GL_GROUP_ENC="$(jq -rn --arg x "${GL_GROUP}" '$x|@uri')"
          GH_USER="${GHCR_USER:-${GITHUB_ACTOR}}"
          [[ -n "${GH_USER}" ]] || { echo "Failed to resolve GH username"; exit 1; }

          host="${GL_URL#*://}"; host="${host##*@}"; host="${host%%/*}"
          if [[ -n "${GL_REGISTRY:-}" ]]; then
            GL_REG="${GL_REGISTRY}"
          else
            if [[ "${host}" == "gitlab.com" ]]; then
              GL_REG="registry.gitlab.com"
            else
              GL_REG="registry.${host}"
            fi
          fi

          # Resolve GitLab username for registry login; fall back to oauth2
          GL_USER="$(curl -s ${CURL_FLAGS} -H "PRIVATE-TOKEN: ${GL_TOKEN}" -H "Accept: application/json" -H "Connection: close" \
            "${GL_API}/user" | jq -r '.username // empty')"
          [[ -z "${GL_USER}" || "${GL_USER}" == "null" ]] && GL_USER="oauth2"

          {
            echo "gl_api=${GL_API}"
            echo "gl_enc=${GL_ENC}"
            echo "gl_group_enc=${GL_GROUP_ENC}"
            echo "gl_reg=${GL_REG}"
            echo "gh_user=${GH_USER}"
            echo "gl_user=${GL_USER}"
          } >> "$GITHUB_OUTPUT"

      - name: Login to GHCR for skopeo
        shell: bash
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          GH_USER: ${{ steps.ids.outputs.gh_user }}
          GHCR_HOST: ${{ steps.hosts.outputs.ghcr_host }}
        run: |
          set -euo pipefail
          skopeo login "${GHCR_HOST}" --username "${GH_USER}" --password-stdin <<< "${GH_PAT}"

      - name: Discover GitLab container repositories (project-level, with group fallback)
        id: gl_repos
        shell: bash
        env:
          GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
          GL_API: ${{ steps.ids.outputs.gl_api }}
          GL_ENC: ${{ steps.ids.outputs.gl_enc }}
          GL_GROUP_ENC: ${{ steps.ids.outputs.gl_group_enc }}
          CURL_FLAGS: ${{ env.CURL_FLAGS }}
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail

          # --- Project-level pagination & accumulation (robust) ---
          page=1
          repos_file="$(mktemp)"
          echo "[]" > "${repos_file}"

          while :; do
            RESP="$(mktemp)"; HDR="$(mktemp)"
            HTTP=$(curl --fail-with-body -sS ${CURL_FLAGS} \
              -H "PRIVATE-TOKEN: ${GL_TOKEN}" -H "Accept: application/json" -H "Connection: close" \
              -D "${HDR}" -w '%{http_code}' \
              "${GL_API}/projects/${GL_ENC}/registry/repositories?per_page=100&page=${page}" \
              -o "${RESP}" ) || { echo "::notice::Failed to list container repositories"; break; }

            if [[ "${HTTP}" != "200" ]]; then
              echo "::notice::No container repositories (HTTP ${HTTP})."
              break
            fi

            if [[ "$(jq -r 'type' "${RESP}")" != "array" ]]; then
              echo "::notice::Response not array"
              break
            fi

            tmp="$(mktemp)"
            jq -c -s '.[0] + .[1]' "${repos_file}" "${RESP}" > "${tmp}"
            mv "${tmp}" "${repos_file}"

            next="$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')"
            [[ -z "${next:-}" || "${next}" == "0" ]] && break
            page="${next}"
          done

          repos="$(cat "${repos_file}")"
          count="$(jq -r 'length' <<< "${repos}" 2>/dev/null || echo 0)"

          # --- Group-level fallback (filter to this project path or location match) ---
          if [[ "${count}" == "0" ]]; then
            GRP_JSON="$(mktemp)"
            HTTP_G=$(curl --fail-with-body -sS ${CURL_FLAGS} \
              -H "PRIVATE-TOKEN: ${GL_TOKEN}" -H "Accept: application/json" -H "Connection: close" \
              -w '%{http_code}' \
              "${GL_API}/groups/${GL_GROUP_ENC}/registry/repositories?per_page=100" \
              -o "${GRP_JSON}" ) || true

            if [[ "${HTTP_G}" == "200" && "$(jq -r 'type' "${GRP_JSON}")" == "array" ]]; then
              filtered="$(jq -c --arg p "${GL_PROJECT}" \
                '[ .[] | select((.path == $p) or (.location? | tostring | contains($p))) ]' "${GRP_JSON}")"
              fcount="$(jq -r 'length' <<< "${filtered}")"
              if [[ "${fcount}" != "0" ]]; then
                repos="${filtered}"
                count="${fcount}"
                echo "Used group-level fallback; matched ${count} repo(s) for project context."
              fi
            fi
          fi

          printf 'list=%s\n' "${repos}" >> "$GITHUB_OUTPUT"
          echo "repo_count=${count}" >> "$GITHUB_OUTPUT"
          echo "Found ${count} container repo(s) in GitLab project."

      - name: Debug – project registry status & raw repos API (when none found)
        if: ${{ steps.gl_repos.outputs.repo_count == '0' }}
        shell: bash
        env:
          GL_URL: ${{ env.GL_URL }}
          GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
          GL_API: ${{ steps.ids.outputs.gl_api }}
          GL_ENC: ${{ steps.ids.outputs.gl_enc }}
          CURL_FLAGS: ${{ env.CURL_FLAGS }}
        run: |
          set -euo pipefail
          PROJ_JSON="$(mktemp)"
          HTTP_P=$(curl -sS ${CURL_FLAGS} \
            -H "PRIVATE-TOKEN: ${GL_TOKEN}" -H "Accept: application/json" -H "Connection: close" \
            -w '%{http_code}' "${GL_API}/projects/${GL_ENC}" -o "${PROJ_JSON}")
          echo "Project GET HTTP: ${HTTP_P}"
          if [[ "${HTTP_P}" == "200" ]]; then
            echo "container_registry_enabled: $(jq -r '.container_registry_enabled // empty' "${PROJ_JSON}")"
            echo "container_registry_access_level: $(jq -r '.container_registry_access_level // empty' "${PROJ_JSON}")"
          fi

          REPOS_JSON="$(mktemp)"
          HTTP_R=$(curl -sS ${CURL_FLAGS} \
            -H "PRIVATE-TOKEN: ${GL_TOKEN}" -H "Accept: application/json" -H "Connection: close" \
            -w '%{http_code}' "${GL_API}/projects/${GL_ENC}/registry/repositories?per_page=100" -o "${REPOS_JSON}")
          echo "Repos GET HTTP: ${HTTP_R}"
          echo "First 500 bytes of repos API body:"
          head -c 500 "${REPOS_JSON}" || true

      - name: Copy all tags from GitLab registry → GHCR (API + skopeo fallback)
        if: ${{ steps.gl_repos.outputs.repo_count != '0' && steps.gl_repos.outputs.list != '[]' }}
        id: copy
        shell: bash
        env:
          REPO_LIST: ${{ steps.gl_repos.outputs.list }}
          GL_URL: ${{ env.GL_URL }}
          GL_REG: ${{ steps.ids.outputs.gl_reg }}
          GL_ENC: ${{ steps.ids.outputs.gl_enc }}
          GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
          GL_USER: ${{ steps.ids.outputs.gl_user }}
          GH_OWNER: ${{ env.GH_OWNER }}
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
          GHCR_HOST: ${{ steps.hosts.outputs.ghcr_host }}
          DRY_RUN: ${{ env.DRY_RUN }}
          GL_PROJECT: ${{ matrix.project }}
          CURL_FLAGS: ${{ env.CURL_FLAGS }}
        run: |
          set -euo pipefail

          json="${REPO_LIST}"
          count="$(jq -r 'length' <<< "${json}" 2>/dev/null || echo 0)"
          echo "Processing ${count} container repo(s)..."

          declare -A TOUCHED=() LOGGED=()

          try_login(){ local d="$1" u="$2" p="$3"; skopeo login "$d" --username "$u" --password-stdin <<< "$p"; }

          for i in $(seq 0 $((count-1))); do
            obj="$(jq -c ".[$i]" <<< "${json}")"
            loc="$(jq -r '.location // empty' <<< "${obj}")"
            path="$(jq -r '.path // empty' <<< "${obj}")"

            if [[ -n "${loc}" ]]; then
              reg_domain="${loc%%/*}"
              reg_path="${loc#*/}"
            elif [[ -n "${path}" ]]; then
              reg_domain="${GL_REG}"
              reg_path="${path}"
            else
              echo "::warning::Missing location/path; skipping: ${obj}"
              continue
            fi

            repo_id="$(jq -r '.id' <<< "${obj}")"

            # -------- 1) Try GitLab API to list tags (paginated) --------
            tags="[]"; page=1; api_http=""
            while :; do
              RESP="$(mktemp)"; HDR="$(mktemp)"
              if ! api_http=$(curl -sS ${CURL_FLAGS} \
                    -H "PRIVATE-TOKEN: ${GL_TOKEN}" -H "Accept: application/json" -H "Connection: close" \
                    -D "${HDR}" -w '%{http_code}' \
                    "${GL_URL%/}/api/v4/projects/${GL_ENC}/registry/repositories/${repo_id}/tags?per_page=100&page=${page}" \
                    -o "${RESP}"); then
                echo "::warning::Failed to list tags (API) for repo_id=${repo_id}; will try skopeo."
                break
              fi

              if [[ "$(jq -r 'type' "${RESP}")" != "array" ]]; then
                echo "::notice::Tags API response not array for repo_id=${repo_id}; stopping API pagination."
                break
              fi

              tags="$(jq -c --argjson acc "${tags}" --argjson cur "$(cat "${RESP}")" '($acc + $cur)')"

              next="$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')"
              [[ -z "${next:-}" || "${next}" == "0" ]] && break
              page="${next}"
            done

            tcount="$(jq -r 'length' <<< "${tags}" 2>/dev/null || echo 0)"

            # -------- 2) If API shows zero, fallback to skopeo list-tags --------
            if [[ "${tcount}" -eq 0 ]]; then
              echo "::notice::API found 0 tags for ${reg_domain}/${reg_path}; trying skopeo list-tags ..."
              # Use explicit credentials to avoid relying on prior login timing
              SRC_CREDS="${GL_USER}:${GL_TOKEN}"
              sk_json="$(skopeo list-tags --creds "${SRC_CREDS}" "docker://${reg_domain}/${reg_path}" 2>/dev/null || true)"
              st_count="$(jq -r '.Tags | length' <<< "${sk_json}" 2>/dev/null || echo 0)"

              if [[ "${st_count}" -gt 0 ]]; then
                # Convert to array of objects with {name: "..."} to reuse the downstream loop
                tags="$(jq -c '.Tags | map({name:.})' <<< "${sk_json}")"
                tcount="${st_count}"
                echo "skopeo found ${tcount} tag(s) for ${reg_domain}/${reg_path}."
              else
                echo "::notice::No tags found for ${reg_domain}/${reg_path}; skipping."
                continue
              fi
            fi

            # -------- Compute destination path (preserve suffix) --------
            suffix="${reg_path#${GL_PROJECT}}"
            if [[ "${suffix}" == "${reg_path}" ]]; then
              proj_name="${GL_PROJECT##*/}"
              suffix="/${reg_path#*${proj_name}}"
            fi
            suffix="${suffix#/}"

            dest_path="${GH_OWNER}/${GH_REPO}"
            [[ -n "${suffix}" ]] && dest_path="${dest_path}/${suffix}"

            echo "→ ${reg_domain}/${reg_path} ==> ${GHCR_HOST}/${dest_path} (${tcount} tag(s))"

            # Login to source registry once per domain (for the actual copy)
            if [[ -z "${LOGGED[${reg_domain}]:-}" ]]; then
              if  try_login "${reg_domain}" "${GL_USER}" "${GL_TOKEN}" \
               || try_login "${reg_domain}" "oauth2" "${GL_TOKEN}" \
               || try_login "${reg_domain}" "gitlab-ci-token" "${GL_TOKEN}"
              then
                LOGGED["${reg_domain}"]=1
              else
                echo "::warning::Login failed for ${reg_domain} (copy may fail)."
              fi
            fi

            while IFS= read -r t; do
              SRC="docker://${reg_domain}/${reg_path}:${t}"
              DEST="docker://${GHCR_HOST}/${dest_path}:${t}"

              if [[ "${DRY_RUN}" == "true" ]]; then
                echo "DRY-RUN skopeo copy --all ${SRC} -> ${DEST}"
                continue
              fi

              echo "Copying tag '${t}' ..."
              if skopeo copy --all "${SRC}" "${DEST}"; then
                pkg_name="${dest_path#${GH_OWNER}/}"
                TOUCHED["${pkg_name}"]=1
              else
                echo "::warning::skopeo copy failed for tag '${t}' (${SRC} -> ${DEST})"
              fi
            done < <(jq -r '.[].name' <<< "${tags}")
          done

          # Emit touched package names
          { for k in "${!TOUCHED[@]}"; do printf '%s\n' "$k"; done; } \
            | jq -R . | jq -s -c . | sed 's/^/pkg_names=/' >> "$GITHUB_OUTPUT"

      - name: (Optional) Set GHCR packages visibility = PUBLIC
        if: ${{ always() && steps.copy.outputs.pkg_names != '' && steps.copy.outputs.pkg_names != '[]' && github.event.inputs.make_public == 'true' }}
        shell: bash
        env:
          PKG_NAMES: ${{ steps.copy.outputs.pkg_names }}
          GH_OWNER: ${{ env.GH_OWNER }}
          GH_PAT: ${{ secrets.GH_PAT }}
          API: ${{ github.api_url }}
        run: |
          set -euo pipefail
          mapfile -t names < <(jq -r '.[]' <<< "${PKG_NAMES}")
          for n in "${names[@]}"; do
            echo "Attempt PUBLIC visibility for: ${n}"
            curl -fsS -X PATCH -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
              "${API}/orgs/${GH_OWNER}/packages/container/${n}" -d '{"visibility":"public"}' \
              && { echo "Org package set to public: ${n}"; continue; } || true
            curl -fsS -X PATCH -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
              "${API}/users/${GH_OWNER}/packages/container/${n}" -d '{"visibility":"public"}' \
              && { echo "User package set to public: ${n}"; continue; } || true
            echo "::notice::Could not set visibility via API for ${n}. Use UI Package Settings if required."
          done

      - name: Summary (containers)
        if: always()
        run: echo "Container image migration finished for ${{ matrix.project }} (GL → GHCR)."
