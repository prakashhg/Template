
name: Mirroring (GitLab â†’ GitHub) + Trackers migration [Production]

on:
  push:
  delete:
  workflow_dispatch: {}

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  # 1) Repo Migration Â· 1.1 Commit Sync (mirror branches & commits)
  repo_migration_commit_sync:
    name: "1) Repo Migration Â· 1.1 Commit Sync"
    runs-on: ubuntu-latest
    # ðŸš« Skip entire job if GH_REPO (from vars) is deletion-scheduled
    if: ${{ !contains(vars.GH_REPO, 'deletion_scheduled-') }}
    outputs:
      gl_url: ${{ steps.export.outputs.gl_url }}
      gl_project: ${{ steps.export.outputs.gl_project }}
      gh_owner: ${{ steps.export.outputs.gh_owner }}
      gh_repo: ${{ steps.export.outputs.gh_repo }}
      auto_create: ${{ steps.export.outputs.auto_create }}
      delete_first: ${{ steps.export.outputs.delete_first }}
      migrate_mrs: ${{ steps.export.outputs.migrate_mrs }}
      init_if_empty_dest: ${{ steps.export.outputs.init_if_empty_dest }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      VAR_GL_URL: ${{ vars.GL_URL }}
      VAR_GL_PROJECT: ${{ vars.GL_PROJECT }}
      VAR_GH_OWNER: ${{ vars.GH_OWNER }}
      VAR_GH_REPO: ${{ vars.GH_REPO }}
      VAR_AUTO_CREATE: ${{ vars.AUTO_CREATE_REPO }}
      VAR_DELETE_FIRST: ${{ vars.DELETE_DEST_REPO_FIRST }} # ignored; we do not delete
      VAR_MIGRATE_MRS: ${{ vars.MIGRATE_MRS }}
      VAR_INIT_IF_EMPTY_DEST: ${{ vars.INIT_IF_EMPTY_DEST }} # optional: initialize destination when source has no branches (default false)
    steps:
      - name: Install tools
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq curl git

      - name: Resolve configuration (vars/secrets only)
        id: cfg
        shell: bash
        run: |
          set -euo pipefail
          GL_URL="${VAR_GL_URL:-https://gitlab.com}"
          GL_PROJECT="${VAR_GL_PROJECT:-}"
          GH_OWNER="${VAR_GH_OWNER:-}"
          GH_REPO="${VAR_GH_REPO:-}"
          AUTO_CREATE="${VAR_AUTO_CREATE:-true}"
          DELETE_FIRST="${VAR_DELETE_FIRST:-false}" # not used
          MIGRATE_MRS="${VAR_MIGRATE_MRS:-true}"
          INIT_IF_EMPTY_DEST="${VAR_INIT_IF_EMPTY_DEST:-false}"

          [[ -z "${GL_PROJECT}" ]] && echo "ERROR: GL_PROJECT required (vars)" && exit 1
          [[ -z "${GH_OWNER}" || -z "${GH_REPO}" ]] && echo "ERROR: GH_OWNER/GH_REPO required (vars)" && exit 1
          [[ -z "${GL_TOKEN:-}" ]] && echo "ERROR: Missing secret GITLAB_TOKEN" && exit 1
          [[ -z "${GH_PAT:-}" ]] && echo "ERROR: Missing secret GH_PAT (PAT classic with repo+workflow scopes)" && exit 1

          {
            echo "GL_URL=${GL_URL}"
            echo "GL_PROJECT=${GL_PROJECT}"
            echo "GH_OWNER=${GH_OWNER}"
            echo "GH_REPO=${GH_REPO}"
            echo "AUTO_CREATE=${AUTO_CREATE}"
            echo "DELETE_FIRST=${DELETE_FIRST}"
            echo "MIGRATE_MRS=${MIGRATE_MRS}"
            echo "INIT_IF_EMPTY_DEST=${INIT_IF_EMPTY_DEST}"
            echo "WORKDIR=/tmp/mirror-work"
          } >> "$GITHUB_ENV"

      - name: Export job outputs
        id: export
        shell: bash
        run: |
          {
            echo "gl_url=${GL_URL}"
            echo "gl_project=${GL_PROJECT}"
            echo "gh_owner=${GH_OWNER}"
            echo "gh_repo=${GH_REPO}"
            echo "auto_create=${AUTO_CREATE}"
            echo "delete_first=${DELETE_FIRST}"
            echo "migrate_mrs=${MIGRATE_MRS}"
            echo "init_if_empty_dest=${INIT_IF_EMPTY_DEST}"
          } >> "$GITHUB_OUTPUT"

      # âŒ Deletion step removed â€” we never delete destination repos

      - name: Create GitHub repo if missing
        if: env.AUTO_CREATE == 'true'
        shell: bash
        run: |
          set -euo pipefail
          REPO_API="https://api.github.com/repos/${GH_OWNER}/${GH_REPO}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_PAT}" "${REPO_API}")
          if [[ "${STATUS}" == "200" ]]; then
            echo "Repo already exists."
          else
            MY_LOGIN=$(curl -s -H "Authorization: Bearer ${GH_PAT}" https://api.github.com/user | jq -r '.login')
            if [[ "${GH_OWNER}" == "${MY_LOGIN}" ]]; then
              CREATE_URL="https://api.github.com/user/repos"
            else
              CREATE_URL="https://api.github.com/orgs/${GH_OWNER}/repos"
            fi
            PAYLOAD=$(jq -n --arg name "${GH_REPO}" '{name:$name, private:true, has_issues:true, has_projects:true, has_wiki:true}')
            RESP=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -H "Authorization: Bearer ${GH_PAT}" \
              -H "Content-Type: application/json" -d "${PAYLOAD}" "${CREATE_URL}")
            HTTP=$(echo "${RESP}" | sed -n 's/^HTTP_STATUS://p')
            if [[ "${HTTP}" != "201" ]]; then
              echo "Failed to create repo (HTTP ${HTTP})."; exit 1
            fi
          fi
          echo "GH repo ready: https://github.com/${GH_OWNER}/${GH_REPO}"
          sleep 1

      - name: Prepare GitLab API (safe encoding)
        id: glapi
        shell: bash
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')
          echo "GL_API=${GL_API}" >> "$GITHUB_ENV"
          echo "GL_ENC=${GL_ENC}" >> "$GITHUB_ENV"

      - name: Check GitLab source branches (skip mirror if empty)
        id: srcbranches
        shell: bash
        run: |
          set -euo pipefail
          RESP=$(mktemp)
          if ! curl --fail-with-body -s -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/projects/${GL_ENC}/repository/branches?per_page=1" > "${RESP}"; then
            echo "ERROR: Could not list GitLab branches"; head -c 300 "${RESP}" || true; exit 1
          fi
          TYPE=$(jq -r 'type' "${RESP}" 2>/dev/null || echo "unknown")
          if [[ "${TYPE}" != "array" ]]; then
            echo "WARN: Unexpected GitLab response for branches (type=${TYPE})"; head -c 300 "${RESP}" || true
            echo "has_branches=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          COUNT=$(jq 'length' "${RESP}")
          if [[ "${COUNT}" -ge 1 ]]; then
            echo "GitLab source has ${COUNT} branches."
            echo "has_branches=true" >> "$GITHUB_OUTPUT"
          else
            echo "GitLab source has NO branches."
            echo "has_branches=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Clone GitLab --mirror and push to GitHub
        if: steps.srcbranches.outputs.has_branches == 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${WORKDIR}"
          cd "${WORKDIR}"
          HOST="${GL_URL#*://}"
          SRC_URL="https://oauth2:${GL_TOKEN}@${HOST}/${GL_PROJECT}.git"
          echo "Cloning --mirror from ${GL_URL}/${GL_PROJECT}"
          git clone --mirror "${SRC_URL}" src.git
          echo "Local refs preview (first 10):"
          git -C src.git show-ref | head -n 10 || true

          cd src.git
          git remote -v
          PUSH_URL="https://x-access-token:${GH_PAT}@github.com/${GH_OWNER}/${GH_REPO}.git"
          git remote remove github 2>/dev/null || true
          git remote add github "${PUSH_URL}"
          echo "Pushing --mirror to ${GH_OWNER}/${GH_REPO}..."
          git push --mirror github

      - name: Optionally initialize destination if source is empty
        if: steps.srcbranches.outputs.has_branches != 'true' && env.INIT_IF_EMPTY_DEST == 'true'
        shell: bash
        run: |
          set -euo pipefail
          # Determine GitLab project's default branch or fallback to 'main'
          PINFO=$(mktemp)
          if ! curl --fail-with-body -s -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
               "${GL_API}/projects/${GL_ENC}" > "${PINFO}"; then
            echo "WARN: Could not fetch GitLab project info; falling back to 'main'"
            DEFAULT_BRANCH="main"
          else
            DEFAULT_BRANCH=$(jq -r '.default_branch // "main"' "${PINFO}")
          fi
          echo "Initializing destination with a README on branch '${DEFAULT_BRANCH}'..."

          CONTENT=$(printf '# %s\n\nThis repository was initialized by migration workflow because the GitLab source contained no branches.\n' "${GH_REPO}" | base64 -w0)
          PUT_RESP=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
            -X PUT -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg msg "Initialize ${DEFAULT_BRANCH}" --arg content "${CONTENT}" --arg branch "${DEFAULT_BRANCH}" \
                  '{message:$msg, content:$content, branch:$branch}')" \
            "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/README.md")
          HTTP=$(echo "${PUT_RESP}" | sed -n 's/^HTTP_STATUS://p')
          if [[ "${HTTP}" != "201" && "${HTTP}" != "200" ]]; then
            echo "ERROR: Failed to initialize repository (HTTP ${HTTP})."; exit 1
          fi

          # Ensure default_branch is set to DEFAULT_BRANCH
          PATCH_HTTP=$(curl -s -o /dev/null -w "%{http_code}" \
            -X PATCH -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
            -d "{\"default_branch\":\"${DEFAULT_BRANCH}\"}" \
            "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}")
          if [[ "${PATCH_HTTP}" != "200" ]]; then
            echo "WARN: Could not set default_branch (HTTP ${PATCH_HTTP})."
          fi
          echo "Destination initialized with README on '${DEFAULT_BRANCH}'."

  # 1) Repo Migration Â· 1.2 Tag Sync
  repo_migration_tag_sync:
    name: "1) Repo Migration Â· 1.2 Tag Sync"
    needs: repo_migration_commit_sync
    runs-on: ubuntu-latest
    if: ${{ !contains(needs.repo_migration_commit_sync.outputs.gh_repo, 'deletion_scheduled-') }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_URL: ${{ needs.repo_migration_commit_sync.outputs.gl_url }}
      GL_PROJECT: ${{ needs.repo_migration_commit_sync.outputs.gl_project }}
      GH_OWNER: ${{ needs.repo_migration_commit_sync.outputs.gh_owner }}
      GH_REPO: ${{ needs.repo_migration_commit_sync.outputs.gh_repo }}
      WORKDIR: /tmp/mirror-work
    steps:
      - name: Install git
        run: |
          sudo apt-get update -y
          sudo apt-get install -y git

      - name: Skip tag sync if source has no branches
        shell: bash
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')
          RESP=$(mktemp)
          curl --fail-with-body -s -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
            "${GL_API}/projects/${GL_ENC}/repository/branches?per_page=1" > "${RESP}" || { echo "No branches â€“ skipping tags"; exit 0; }
          [ "$(jq -r 'type' "${RESP}")" = "array" ] || { echo "Unexpected response â€“ skipping tags"; exit 0; }
          [ "$(jq 'length' "${RESP}")" -ge 1 ] || { echo "No branches â€“ skipping tags"; exit 0; }

      - name: Fetch tags from GitLab and push to GitHub
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${WORKDIR}"
          cd "${WORKDIR}"
          HOST="${GL_URL#*://}"
          SRC_URL="https://oauth2:${GL_TOKEN}@${HOST}/${GL_PROJECT}.git"
          if [[ ! -d src.git ]]; then
            git clone --mirror "${SRC_URL}" src.git
          fi
          cd src.git
          git fetch --tags origin
          PUSH_URL="https://x-access-token:${GH_PAT}@github.com/${GH_OWNER}/${GH_REPO}.git"
          git remote remove github 2>/dev/null || true
          git remote add github "${PUSH_URL}"
          echo "Pushing tags..."
          git push --tags github

  # 1) Repo Migration Â· 1.3 PR Sync (MR â†’ PR) â€” robust
  repo_migration_pr_sync:
    name: "1) Repo Migration Â· 1.3 PR Sync (MR â†’ PR)"
    needs: repo_migration_commit_sync
    runs-on: ubuntu-latest
    if: ${{ needs.repo_migration_commit_sync.outputs.migrate_mrs == 'true' && !contains(needs.repo_migration_commit_sync.outputs.gh_repo, 'deletion_scheduled-') }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_URL: ${{ needs.repo_migration_commit_sync.outputs.gl_url }}
      GL_PROJECT: ${{ needs.repo_migration_commit_sync.outputs.gl_project }}
      GH_OWNER: ${{ needs.repo_migration_commit_sync.outputs.gh_owner }}
      GH_REPO: ${{ needs.repo_migration_commit_sync.outputs.gh_repo }}
    steps:
      - name: Install jq & curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Prepare GitLab API (safe encoding)
        shell: bash
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')
          echo "GL_API=${GL_API}" >> "$GITHUB_ENV"
          echo "GL_ENC=${GL_ENC}" >> "$GITHUB_ENV"

      - name: Migrate merge requests â†’ pull requests
        shell: bash
        run: |
          set -euo pipefail
          : "${GH_OWNER:?GH_OWNER empty}"
          : "${GH_REPO:?GH_REPO empty}"
          : "${GL_API:?GL_API empty}"
          : "${GL_ENC:?GL_ENC empty}"

          page=1
          while true; do
            RESP=$(mktemp) ; HDR=$(mktemp)
            if ! curl --fail-with-body -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/projects/${GL_ENC}/merge_requests?scope=all&per_page=100&page=${page}" > "${RESP}"; then
              echo "ERROR: GitLab MRs API non-2xx"; cat "${HDR}" || true; head -c 300 "${RESP}" || true; exit 1
            fi
            [[ "$(jq -r 'type' "${RESP}")" == "array" ]] || { echo "WARN: MRs response not array"; head -c 300 "${RESP}" || true; break; }

            jq -c '.[]' "${RESP}" | while IFS= read -r mr; do
              title=$(printf '%s' "${mr}" | jq -r '.title')
              body=$(printf '%s' "${mr}" | jq -r '.description // ""')
              state=$(printf '%s' "${mr}" | jq -r '.state')
              labels=$(printf '%s' "${mr}" | jq -c '.labels')
              source_branch=$(printf '%s' "${mr}" | jq -r '.source_branch')
              target_branch=$(printf '%s' "${mr}" | jq -r '.target_branch')
              author=$(printf '%s' "${mr}" | jq -r '.author.username')
              gl_iid=$(printf '%s' "${mr}" | jq -r '.iid')

              HEAD_OK=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_PAT}" \
                "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/git/refs/heads/${source_branch}")
              BASE_OK=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_PAT}" \
                "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/git/refs/heads/${target_branch}")

              if [[ "${HEAD_OK}" != "200" || "${BASE_OK}" != "200" ]]; then
                echo "Skip MR#${gl_iid}: missing head/base (${source_branch}â†’${target_branch})"
                continue
              fi

              CREATE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -H "Authorization: Bearer ${GH_PAT}" \
                -H "Accept: application/vnd.github+json" \
                -d "$(jq -n --arg title "${title}" \
                      --arg body "**Imported from GitLab by @${author}**\n\n${body}" \
                      --arg head "${source_branch}" --arg base "${target_branch}" \
                      '{title:$title, body:$body, head:$head, base:$base}')" \
                "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/pulls")

              http=$(echo "${CREATE}" | sed -n 's/^HTTP_STATUS://p')
              pr_num=$(echo "${CREATE}" | sed '/^HTTP_STATUS:/d' | jq -r '.number // empty')
              echo "PR create status=${http} number=${pr_num}"

              if [[ -n "${pr_num}" && "${labels}" != "null" ]]; then
                curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_PAT}" \
                  -H "Accept: application/vnd.github+json" -d "${labels}" \
                  "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/issues/${pr_num}/labels" >/dev/null
                sleep 1
              fi

              if [[ -n "${pr_num}" ]]; then
                if [[ "${state}" == "closed" ]] ; then
                  curl -s -o /dev/null -w "%{http_code}" -X PATCH -H "Authorization: Bearer ${GH_PAT}" \
                    -H "Accept: application/vnd.github+json" -d '{"state":"closed"}' \
                    "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/issues/${pr_num}" >/dev/null
                elif [[ "${state}" == "merged" ]]; then
                  curl -s -o /dev/null -w "%{http_code}" -X PUT -H "Authorization: Bearer ${GH_PAT}" \
                    -H "Accept: application/vnd.github+json" -d '{"merge_method":"merge"}' \
                    "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/pulls/${pr_num}/merge" >/dev/null
                fi
                sleep 1
              fi

              # Comments
              cpage=1
              while true; do
                CRESP=$(mktemp) ; CHDR=$(mktemp)
                if ! curl --fail-with-body -s -D "${CHDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
                     "${GL_API}/projects/${GL_ENC}/merge_requests/${gl_iid}/notes?activity_filter=only_comments&per_page=100&page=${cpage}" > "${CRESP}"; then
                  echo "WARN: MR comments non-2xx for MR#${gl_iid} page ${cpage}"; head -c 300 "${CRESP}" || true; break
                fi
                [[ "$(jq -r 'type' "${CRESP}")" == "array" ]] || { echo "WARN: comments response not array"; head -c 300 "${CRESP}" || true; break; }

                jq -c '.[]' "${CRESP}" | while IFS= read -r note; do
                  nbody=$(printf '%s' "${note}" | jq -r '.body')
                  nauth=$(printf '%s' "${note}" | jq -r '.author.username')
                  curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_PAT}" \
                    -H "Accept: application/vnd.github+json" \
                    -d "$(jq -n --arg b "**@${nauth} (from GitLab)**\n\n${nbody}" '{body:$b}')" \
                    "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/issues/${pr_num}/comments" >/dev/null
                  sleep 1
                done

                nnext=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${CHDR}" | tr -d '\r')
                [[ -z "${nnext}" || "${nnext}" == "0" ]] && break
                cpage="${nnext}"
              done
            done

            next=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')
            [[ -z "${next}" || "${next}" == "0" ]] && break
            page="${next}"
          done

  # 1) Repo Migration Â· 1.4 Label Sync â€” robust
  repo_migration_label_sync:
    name: "1) Repo Migration Â· 1.4 Label Sync"
    needs: repo_migration_commit_sync
    runs-on: ubuntu-latest
    if: ${{ !contains(needs.repo_migration_commit_sync.outputs.gh_repo, 'deletion_scheduled-') }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_URL: ${{ needs.repo_migration_commit_sync.outputs.gl_url }}
      GL_PROJECT: ${{ needs.repo_migration_commit_sync.outputs.gl_project }}
      GH_OWNER: ${{ needs.repo_migration_commit_sync.outputs.gh_owner }}
      GH_REPO: ${{ needs.repo_migration_commit_sync.outputs.gh_repo }}
    steps:
      - name: Install jq & curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Prepare GitLab API (safe encoding)
        shell: bash
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')
          echo "GL_API=${GL_API}" >> "$GITHUB_ENV"
          echo "GL_ENC=${GL_ENC}" >> "$GITHUB_ENV"

      - name: Migrate labels
        shell: bash
        run: |
          set -euo pipefail
          page=1
          while true; do
            RESP=$(mktemp) ; HDR=$(mktemp)
            if ! curl --fail-with-body -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/projects/${GL_ENC}/labels?per_page=100&page=${page}" > "${RESP}"; then
              echo "ERROR: GitLab Labels API non-2xx"; cat "${HDR}" || true; head -c 300 "${RESP}" || true; exit 1
            fi
            [[ "$(jq -r 'type' "${RESP}")" == "array" ]] || { echo "WARN: labels response not array"; head -c 300 "${RESP}" || true; break; }

            jq -c '.[]' "${RESP}" | while IFS= read -r lbl; do
              name=$(printf '%s' "${lbl}" | jq -r '.name')
              color=$(printf '%s' "${lbl}" | jq -r '.color' | sed 's/^#//')
              description=$(printf '%s' "${lbl}" | jq -r '.description // empty')

              CREATE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
                -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
                -H "Content-Type: application/json" \
                -d "$(jq -n --arg name "${name}" --arg color "${color}" --arg desc "${description}" \
                      '{name:$name, color:$color, description:$desc}')" \
                "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/labels")
              ST=$(echo "${CREATE}" | sed -n 's/^HTTP_STATUS://p')
              if [[ "${ST}" != "201" ]]; then
                NAME_ENC=$(jq -rn --arg x "${name}" '$x|@uri')
                curl -s -o /dev/null -w "%{http_code}" -X PATCH \
                  -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
                  -H "Content-Type: application/json" \
                  -d "$(jq -n --arg new "${name}" --arg color "${color}" --arg desc "${description}" \
                        '{new_name:$new, color:$color, description:$desc}')" \
                  "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/labels/${NAME_ENC}" >/dev/null
              fi
              sleep 1
            done

            next=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')
            [[ -z "${next}" || "${next}" == "0" ]] && break
            page="${next}"
          done

  # 1) Repo Migration Â· 1.5 Milestone Sync â€” robust
  repo_migration_milestone_sync:
    name: "1) Repo Migration Â· 1.5 Milestone Sync"
    needs: [repo_migration_commit_sync, repo_migration_label_sync]
    runs-on: ubuntu-latest
    if: ${{ !contains(needs.repo_migration_commit_sync.outputs.gh_repo, 'deletion_scheduled-') }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_URL: ${{ needs.repo_migration_commit_sync.outputs.gl_url }}
      GL_PROJECT: ${{ needs.repo_migration_commit_sync.outputs.gl_project }}
      GH_OWNER: ${{ needs.repo_migration_commit_sync.outputs.gh_owner }}
      GH_REPO: ${{ needs.repo_migration_commit_sync.outputs.gh_repo }}
    steps:
      - name: Install jq & curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Prepare GitLab API (safe encoding)
        shell: bash
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')
          echo "GL_API=${GL_API}" >> "$GITHUB_ENV"
          echo "GL_ENC=${GL_ENC}" >> "$GITHUB_ENV"

      - name: Migrate milestones
        shell: bash
        run: |
          set -euo pipefail
          page=1
          while true; do
            RESP=$(mktemp) ; HDR=$(mktemp)
            if ! curl --fail-with-body -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/projects/${GL_ENC}/milestones?per_page=100&page=${page}" > "${RESP}"; then
              echo "ERROR: GitLab Milestones API non-2xx"; cat "${HDR}" || true; head -c 300 "${RESP}" || true; exit 1
            fi
            [[ "$(jq -r 'type' "${RESP}")" == "array" ]] || { echo "WARN: milestones response not array"; head -c 300 "${RESP}" || true; break; }

            jq -c '.[]' "${RESP}" | while IFS= read -r ms; do
              title=$(printf '%s' "${ms}" | jq -r '.title')
              description=$(printf '%s' "${ms}" | jq -r '.description // empty')
              due=$(printf '%s' "${ms}" | jq -r '.due_date // empty')

              payload=$(jq -n --arg title "${title}" --arg desc "${description}" --arg due "${due}" \
                '{title:$title, description:$desc} + (((($due|length)>0)) ? {due_on:$due} : {})')

              status=$(curl -s -o /dev/null -w "%{http_code}" \
                -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
                -H "Content-Type: application/json" \
                -d "${payload}" \
                "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/milestones")
              echo "Milestone ${title} status: ${status}"
              sleep 1
            done

            next=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')
            [[ -z "${next}" || "${next}" == "0" ]] && break
            page="${next}"
          done

  # 1.6) Discover projects â†’ provides project_list for matrix (filtered)
  discover_projects:
    name: "1.6) Discover GitLab projects for conversion"
    runs-on: ubuntu-latest
    outputs:
      project_list: ${{ steps.collect.outputs.project_list }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GL_URL: ${{ vars.GL_URL }}
      GL_GROUP: ${{ vars.GL_GROUP }}
      REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}
      GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}
      GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }}
    steps:
      - name: Install jq & curl
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Collect & filter projects under GL_GROUP (exclude deletion-scheduled)
        id: collect
        shell: bash
        run: |
          set -euo pipefail
          : "${GL_URL:?GL_URL is required}"

          GL_PROJECT="${{ vars.GL_PROJECT }}"
          DEFAULT_GROUP="${GL_PROJECT%/*}"
          GROUP_VAL="${GL_GROUP:-$DEFAULT_GROUP}"
          : "${GROUP_VAL:?GL_GROUP or default derived group is required}"

          GL_API="${GL_URL%/}/api/v4"
          GROUP_ENC=$(jq -rn --arg x "${GROUP_VAL}" '$x|@uri')

          REPO_NAME_MODE="${REPO_NAME_MODE:-path}"
          GH_REPO_PREFIX="${GH_REPO_PREFIX:-}"
          GH_REPO_SEPARATOR="${GH_REPO_SEPARATOR:-"-"}"

          page=1
          filtered=()
          total=0

          while true; do
            RESP=$(mktemp) ; HDR=$(mktemp)
            curl -s -D "${HDR}" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/groups/${GROUP_ENC}/projects?per_page=100&page=${page}&include_subgroups=true" > "${RESP}"

            while read -r proj; do
              path=$(jq -r '.path_with_namespace' <<< "${proj}")
              [[ -n "${path}" ]] && {
                if [[ "${REPO_NAME_MODE}" == "fullpath" ]]; then
                  base="$(echo "${path}" | tr '/' "${GH_REPO_SEPARATOR}")"
                else
                  base="${path##*/}"
                fi
                dest="${GH_REPO_PREFIX}${base}"
                if [[ "${dest}" == *deletion_scheduled-* ]]; then
                  echo "Exclude (deletion-scheduled): ${dest} (from GL: ${path})"
                else
                  filtered+=("${path}")
                fi
              }
            done < <(jq -c '.[]' "${RESP}")

            next=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "${HDR}" | tr -d '\r')
            [[ -z "${next}" || "${next}" == "0" ]] && break
            page="${next}"
          done

          json=$(printf '%s\n' "${filtered[@]:-}" | jq -R . | jq -s -c .)
          echo "Discovered ${total} projects; included $(jq 'length' <<< "${json}") after filtering"
          echo "project_list=${json}" >> "$GITHUB_OUTPUT"

  # 1.6) GitLab CI â†’ GitHub Actions (dry-run preview)
  ci_migration_dry_run:
    name: "1.6) ${{ matrix.project }} Â· GitLab CI â†’ Actions (dry-run)"
    needs: [discover_projects, repo_migration_commit_sync]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 4
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    env:
      GH_PAT: ${{ secrets.GH_PAT }}
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GL_URL: ${{ vars.GL_URL }}
      GH_OWNER: ${{ vars.GH_OWNER }}
      REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}
      GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}
      GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }}
      GL_GROUP: ${{ vars.GL_GROUP }}
    steps:
      - name: Ensure GitHub CLI & Docker are available
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y gnupg software-properties-common
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | \
              sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
            sudo apt-get update -y
            sudo apt-get install -y gh
          fi
          sudo apt-get install -y jq curl
          if ! command -v docker >/dev/null 2>&1; then
            sudo apt-get install -y docker.io
            sudo systemctl enable --now docker
          fi
          docker --version
          gh --version

      - name: Authenticate gh (for GHCR pulls)
        shell: bash
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          set -euo pipefail
          echo "${GH_PAT}" | gh auth login --with-token --hostname github.com
          gh auth status

      - name: Install Actions Importer extension and verify
        shell: bash
        run: |
          set -euo pipefail
          if ! gh extension list | grep -q '^github/gh-actions-importer'; then
            gh extension install github/gh-actions-importer
          fi
          gh actions-importer -h
          gh actions-importer update

      - name: Compute destination repo name
        id: repo
        shell: bash
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          REPO_NAME_MODE="${REPO_NAME_MODE:-path}"
          GH_REPO_PREFIX="${GH_REPO_PREFIX:-}"
          GH_REPO_SEPARATOR="${GH_REPO_SEPARATOR:-"-"}"
          if [[ "${REPO_NAME_MODE}" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${GH_REPO_SEPARATOR}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          GH_REPO="${GH_REPO_PREFIX}${base}"
          echo "gh_repo=${GH_REPO}" >> "$GITHUB_OUTPUT"
          echo "Computed GH_REPO=${GH_REPO} for GL_PROJECT=${GL_PROJECT}"

      - name: Skip if destination repo is deletion-scheduled
        shell: bash
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          if [[ "${GH_REPO}" == *deletion_scheduled-* ]]; then
            echo "Skipping repo marked for deletion: ${GH_OWNER}/${GH_REPO}"
            exit 0
          fi

      - name: Configure importer via .env.local (non-interactive)
        shell: bash
        run: |
          set -euo pipefail
          cat > .env.local <<EOF
          GITHUB_ACCESS_TOKEN=${GH_PAT}
          GITHUB_INSTANCE_URL=https://github.com
          GITLAB_ACCESS_TOKEN=${GL_TOKEN}
          GITLAB_INSTANCE_URL=${GL_URL}
          EOF

      - name: Dry-run conversion (writes YAML to output dir)
        shell: bash
        env:
          GL_PROJECT: ${{ matrix.project }}
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          mkdir -p "tmp/dry-run/${GH_REPO}"
          gh actions-importer dry-run gitlab \
            --namespace "${GL_GROUP:-${GL_PROJECT%/*}}" \
            --project "${GL_PROJECT##*/}" \
            --output-dir "tmp/dry-run/${GH_REPO}"
          echo "Converted workflow files are in tmp/dry-run/${GH_REPO}"

      - name: Debug dry-run output
        shell: bash
        run: |
          set -euo pipefail
          echo "PWD: $(pwd)"
          ls -la "tmp/dry-run/${{ steps.repo.outputs.gh_repo }}" || true
          find "tmp/dry-run/${{ steps.repo.outputs.gh_repo }}" -maxdepth 2 -type f -print || true

      - name: Upload converted workflow as artifact
        uses: actions/upload-artifact@v4
        with:
          name: glci-to-actions-${{ steps.repo.outputs.gh_repo }}
          path: tmp/dry-run/${{ steps.repo.outputs.gh_repo }}/
          if-no-files-found: warn
          compression-level: 6
          overwrite: false
          include-hidden-files: false

  # 1.6) GitLab CI â†’ GitHub Actions (migrate production: open PR)
  ci_migration_migrate:
    name: "1.6) ${{ matrix.project }} Â· GitLab CI â†’ Actions (migrate)"
    needs: [discover_projects, repo_migration_commit_sync]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    permissions:
      contents: write
      pull-requests: write
    env:
      GH_PAT: ${{ secrets.GH_PAT }} # PAT classic with repo+workflow scopes
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      GL_URL: ${{ vars.GL_URL }}
      GH_OWNER: ${{ vars.GH_OWNER }}
      REPO_NAME_MODE: ${{ vars.REPO_NAME_MODE }}
      GH_REPO_PREFIX: ${{ vars.GH_REPO_PREFIX }}
      GH_REPO_SEPARATOR: ${{ vars.GH_REPO_SEPARATOR }}
      GL_GROUP: ${{ vars.GL_GROUP }}
    steps:
      - name: Ensure GitHub CLI & Docker
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y gnupg software-properties-common
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | \
              sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
            sudo apt-get update -y
            sudo apt-get install -y gh
          fi
          sudo apt-get install -y jq curl
          if ! command -v docker >/dev/null 2>&1; then
            sudo apt-get install -y docker.io
            sudo systemctl enable --now docker
          fi
          docker --version
          gh --version

      - name: Authenticate gh
        shell: bash
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          set -euo pipefail
          echo "${GH_PAT}" | gh auth login --with-token --hostname github.com
          gh auth status

      - name: Install / update Actions Importer extension
        shell: bash
        run: |
          set -euo pipefail
          if ! gh extension list | grep -q '^github/gh-actions-importer'; then
            gh extension install github/gh-actions-importer
          fi
          gh actions-importer update

      - name: Compute destination repo name
        id: repo
        shell: bash
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          REPO_NAME_MODE="${REPO_NAME_MODE:-path}"
          GH_REPO_PREFIX="${GH_REPO_PREFIX:-}"
          GH_REPO_SEPARATOR="${GH_REPO_SEPARATOR:-"-"}"
          if [[ "${REPO_NAME_MODE}" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${GH_REPO_SEPARATOR}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          GH_REPO="${GH_REPO_PREFIX}${base}"
          echo "gh_repo=${GH_REPO}" >> "$GITHUB_OUTPUT"
          echo "Computed GH_REPO=${GH_REPO} for GL_PROJECT=${GL_PROJECT}"

      - name: Skip if destination repo is deletion-scheduled
        shell: bash
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          if [[ "${GH_REPO}" == *deletion_scheduled-* ]]; then
            echo "Skipping repo marked for deletion: ${GH_OWNER}/${GH_REPO}"
            exit 0
          fi

      - name: Configure importer via .env.local
        shell: bash
        run: |
          set -euo pipefail
          cat > .env.local <<EOF
          GITHUB_ACCESS_TOKEN=${GH_PAT}
          GITHUB_INSTANCE_URL=https://github.com
          GITLAB_ACCESS_TOKEN=${GL_TOKEN}
          GITLAB_INSTANCE_URL=${GL_URL}
          EOF

      - name: Ensure destination repo exists (create if missing)
        shell: bash
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${GH_OWNER}/${GH_REPO}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_PAT}" "${API}")
          if [[ "${STATUS}" == "200" ]]; then
            echo "Repo ${GH_OWNER}/${GH_REPO} exists."
          else
            echo "Repo ${GH_OWNER}/${GH_REPO} not found (HTTP ${STATUS}); creating..."
            MY_LOGIN=$(curl -s -H "Authorization: Bearer ${GH_PAT}" https://api.github.com/user | jq -r '.login')
            if [[ "${GH_OWNER}" == "${MY_LOGIN}" ]]; then
              CREATE_URL="https://api.github.com/user/repos"
            else
              CREATE_URL="https://api.github.com/orgs/${GH_OWNER}/repos"
            fi
            PAYLOAD=$(jq -n --arg name "${GH_REPO}" '{name:$name, private:true, has_issues:true, has_projects:true, has_wiki:true}')
            RESP=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -H "Authorization: Bearer ${GH_PAT}" \
              -H "Accept: application/vnd.github+json" -H "Content-Type: application/json" \
              -d "${PAYLOAD}" "${CREATE_URL}")
            HTTP=$(echo "${RESP}" | sed -n 's/^HTTP_STATUS://p')
            if [[ "${HTTP}" != "201" ]]; then
              echo "Failed to create repo ${GH_OWNER}/${GH_REPO} (HTTP ${HTTP})."
              echo "TIP: Ensure GH_PAT has 'repo' + 'workflow' scopes, and caller has rights in ${GH_OWNER}."
              exit 1
            fi
            echo "Created https://github.com/${GH_OWNER}/${GH_REPO}"
          fi

      # ðŸ”§ Preflight to use the default branch only (no 'main' creation)
      - name: Ensure default branch points to an existing branch
        shell: bash
        env:
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${GH_OWNER}/${GH_REPO}"

          for i in {1..30}; do
            BR_LIST="$(curl -s -H "Authorization: Bearer ${GH_PAT}" "${API}/branches?per_page=100")" || BR_LIST="[]"
            BR_LEN="$(jq 'length' <<< "${BR_LIST}" 2>/dev/null || echo 0)"
            if [[ "${BR_LEN}" -ge 1 ]]; then
              echo "Branch(es) detected: ${BR_LEN}"
              break
            fi
            echo "No branches yet; waiting... (${i}/30)"
            sleep 3
          done
          BR_LEN="$(jq 'length' <<< "${BR_LIST}" 2>/dev/null || echo 0)"
          [[ "${BR_LEN}" -lt 1 ]] && { echo "ERROR: No branches found after waiting. Mirror push may have failed or dest uninitialized."; exit 1; }

          CURRENT_DEFAULT="$(curl -s -H "Authorization: Bearer ${GH_PAT}" "${API}" | jq -r '.default_branch // empty')"
          FIRST_BRANCH="$(jq -r '.[0].name' <<< "${BR_LIST}")"
          HAS_DEFAULT="$(jq --arg d "${CURRENT_DEFAULT}" '[ .[].name ] | any(. == $d)' <<< "${BR_LIST}")"
          if [[ -z "${CURRENT_DEFAULT}" || "${CURRENT_DEFAULT}" == "null" || "${HAS_DEFAULT}" != "true" ]]; then
            echo "Updating default branch to '${FIRST_BRANCH}' (existing branch)."
            UPDATE_HTTP="$(curl -s -o /dev/null -w "%{http_code}" \
              -X PATCH -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" \
              -d "{\"default_branch\":\"${FIRST_BRANCH}\"}" \
              "${API}")"
            if [[ "${UPDATE_HTTP}" != "200" ]]; then
              echo "ERROR: Failed to update default branch (HTTP ${UPDATE_HTTP})."; exit 1;
            fi
          else
            echo "Default branch '${CURRENT_DEFAULT}' exists; continuing."
          fi
          echo "Default branch ready."

      - name: Migrate pipeline â†’ open PR adding workflow
        shell: bash
        env:
          GL_PROJECT: ${{ matrix.project }}
          GH_REPO: ${{ steps.repo.outputs.gh_repo }}
          GH_OWNER: ${{ env.GH_OWNER }}
        run: |
          set -euo pipefail
          mkdir -p "tmp/migrate/${GH_REPO}"
          LOG_FILE="$(mktemp)"
          gh actions-importer migrate gitlab \
            --target-url "https://github.com/${GH_OWNER}/${GH_REPO}" \
            --output-dir "tmp/migrate/${GH_REPO}" \
            --namespace "${GL_GROUP:-${GL_PROJECT%/*}}" \
            --project "${GL_PROJECT##*/}" | tee "${LOG_FILE}"

          PR_URL="$(grep -Eo 'https://github.com/.+/pull/[0-9]+' "${LOG_FILE}" | tr -d $'\r' | tr -d '"'\'' | tail -n1 || true)"
          if [[ -n "${PR_URL}" ]]; then
            echo "Migration complete. PR link: ${PR_URL}"
          else
            echo "Migration complete. Check the step log above for the PR URL."
          fi
