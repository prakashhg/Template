
name: "GitLab → GHCR (group-wide container mirror)"

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Print planned copies, don't mirror (true|false)"
        required: false
        default: "true"
      only_project:
        description: "Optional: run ONLY for this GitLab project path (e.g., mygroup/app)"
        required: false
        default: ""

permissions:
  contents: write
  packages: write  # required so GITHUB_TOKEN can push to GHCR

env:
  # ---- REQUIRED ORG/ENDPOINTS ----
  GL_URL:   ${{ vars.GL_URL }}         # e.g., https://gitlab.com
  GL_GROUP: ${{ vars.GL_GROUP }}       # e.g., myorg/platform
  GH_OWNER: ${{ vars.GH_OWNER }}       # e.g., mygithuborg

  # ---- NAMING MODES ----
  CR_NAME_MODE:         ${{ vars.CR_NAME_MODE || 'path' }}   # 'path' or 'fullpath'
  GHCR_IMAGE_PREFIX:    ${{ vars.GHCR_IMAGE_PREFIX }}        # optional, e.g., 'gl-'
  GHCR_IMAGE_SEPARATOR: ${{ vars.GHCR_IMAGE_SEPARATOR || '-' }}

  # ---- FILTERS ----
  CR_REPO_INCLUDE_REGEX: ${{ vars.CR_REPO_INCLUDE_REGEX || '.*' }}
  CR_REPO_EXCLUDE_REGEX: ${{ vars.CR_REPO_EXCLUDE_REGEX || '^$' }}
  CR_TAG_INCLUDE_REGEX:  ${{ vars.CR_TAG_INCLUDE_REGEX  || '.*' }}
  CR_TAG_EXCLUDE_REGEX:  ${{ vars.CR_TAG_EXCLUDE_REGEX  || '^$' }}

jobs:
  check_setup:
    name: "0) Validate setup"
    runs-on: ubuntu-latest
    steps:
      - name: Verify variables/secrets
        run: |
          set -euo pipefail
          [[ -n "${GL_URL:-}"   ]] || { echo "::error::Missing vars.GL_URL"; exit 1; }
          [[ -n "${GL_GROUP:-}" ]] || { echo "::error::Missing vars.GL_GROUP"; exit 1; }
          [[ -n "${GH_OWNER:-}" ]] || { echo "::error::Missing vars.GH_OWNER"; exit 1; }
          [[ -n "${{ secrets.GITLAB_TOKEN }}" ]] || { echo "::error::Missing secret GITLAB_TOKEN"; exit 1; }
          echo "Setup OK: GL_URL=${GL_URL}, GL_GROUP=${GL_GROUP}, GH_OWNER=${GH_OWNER}"

  discover_projects:
    name: "1) Discover GitLab projects (incl. subgroups)"
    runs-on: ubuntu-latest
    needs: check_setup
    outputs:
      project_list:  ${{ steps.out.outputs.project_list }}
      project_count: ${{ steps.out.outputs.project_count }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
    steps:
      - name: Install jq & curl
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Single-project override (if input provided)
        id: single
        run: |
          set -euo pipefail
          pj="${{ github.event.inputs.only_project }}"
          if [[ -n "${pj}" ]]; then
            arr=$(jq -c -n --arg pj "${pj}" '[ $pj ]')
            echo "project_list=${arr}"  >> "$GITHUB_OUTPUT"
            echo "project_count=1"      >> "$GITHUB_OUTPUT"
          fi

      - name: Discover group projects (paginate; robust)
        if: steps.single.outputs.project_list == ''
        id: discover
        run: |
          set -euo pipefail
          GL_API="${GL_URL%/}/api/v4"
          GROUP_ENC=$(jq -rn --arg x "${GL_GROUP}" '$x|@uri')

          tmp=$(mktemp); : > "$tmp"
          page=1
          while : ; do
            RESP=$(mktemp); HDR=$(mktemp)
            curl -fsSL -D "$HDR" -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
              "${GL_API}/groups/${GROUP_ENC}/projects?per_page=100&page=${page}&include_subgroups=true" > "$RESP" || {
              echo "::error::Failed to list projects for ${GL_GROUP}"; exit 1; }

            typ=$(jq -r 'type' "$RESP" 2>/dev/null || echo "unknown")
            [[ "$typ" != "array" ]] && { echo "::error::Unexpected response type=$typ"; head -n 20 "$RESP"; exit 1; }

            # Exclude deletion-scheduled names if you use such a convention
            jq -r '.[].path_with_namespace' "$RESP" |
              grep -vE '^(deletion_scheduled-|.*deletion_scheduled-.*)$' || true >> "$tmp"

            next=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "$HDR" | tr -d '\r')
            [[ -z "$next" || "$next" == "0" ]] && break
            page="$next"
          done

          cnt=$(wc -l < "$tmp" | tr -d '[:space:]')
          if [[ "${cnt}" == "0" ]]; then
            echo "::notice::No projects discovered under ${GL_GROUP}"
            echo "project_list=[]" >> "$GITHUB_OUTPUT"
            echo "project_count=0" >> "$GITHUB_OUTPUT"
          else
            jq -R . < "$tmp" | jq -s -c . | sed 's/^/project_list=/' >> "$GITHUB_OUTPUT"
            echo "project_count=${cnt}" >> "$GITHUB_OUTPUT"
          fi

      - name: Output matrix (safe)
        id: out
        run: |
          set -euo pipefail
          single='${{ steps.single.outputs.project_list }}'
          disc='${{ steps.discover.outputs.project_list }}'
          if [[ -n "${single}" ]]; then
            echo "${single}" | sed 's/^/project_list=/' >> "$GITHUB_OUTPUT"
            echo "project_count=${{ steps.single.outputs.project_count }}" >> "$GITHUB_OUTPUT"
          else
            echo "${disc}" | sed 's/^/project_list=/' >> "$GITHUB_OUTPUT"
            echo "project_count=${{ steps.discover.outputs.project_count }}" >> "$GITHUB_OUTPUT"

  mirror_containers:
    name: "2) Mirror GitLab Container Registry → GHCR"
    needs: discover_projects
    if: ${{ needs.discover_projects.outputs.project_count != '0' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 4
      matrix:
        project: ${{ fromJson(needs.discover_projects.outputs.project_list) }}
    env:
      GL_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      DRY_RUN:  ${{ github.event.inputs.dry_run }}
    steps:
      - name: Install skopeo & jq & curl
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y skopeo jq curl

      - name: Mirror all repos/tags for project
        shell: bash
        env:
          GL_PROJECT: ${{ matrix.project }}
        run: |
          set -euo pipefail
          [[ -z "${GL_PROJECT:-}" || "${GL_PROJECT}" == "null" ]] && { echo "::warning::GL_PROJECT empty – skipping"; exit 0; }

          GL_API="${GL_URL%/}/api/v4"
          GL_ENC=$(jq -rn --arg x "${GL_PROJECT}" '$x|@uri')

          # Destination image base
          if [[ "${CR_NAME_MODE:-path}" == "fullpath" ]]; then
            base="$(echo "${GL_PROJECT}" | tr '/' "${GHCR_IMAGE_SEPARATOR:-'-'}")"
          else
            base="${GL_PROJECT##*/}"
          fi
          IMG_BASE="${GHCR_IMAGE_PREFIX:-}${base}"

          host="${GL_URL#*://}"
          include_repo="${CR_REPO_INCLUDE_REGEX:-.*}"
          exclude_repo="${CR_REPO_EXCLUDE_REGEX:-^$}"
          include_tag="${CR_TAG_INCLUDE_REGEX:-.*}"
          exclude_tag="${CR_TAG_EXCLUDE_REGEX:-^$}"

          echo "Project=${GL_PROJECT}  →  GHCR base=${IMG_BASE}"

          page=1
          while : ; do
            RESP=$(mktemp); HDR=$(mktemp)
            url="${GL_API}/projects/${GL_ENC}/registry/repositories?tags=1&tags_count=true&per_page=100&page=${page}"
            http=$(curl -sS -w '%{http_code}' -o "$RESP" -D "$HDR" -H "PRIVATE-TOKEN: ${GL_TOKEN}" "$url")
            [[ "$http" != "200" ]] && { echo "::warning::GitLab API HTTP $http for $url"; head -n 5 "$RESP"; break; }

            typ=$(jq -r 'type' "$RESP" 2>/dev/null || echo "unknown")
            [[ "$typ" != "array" ]] && { echo "::warning::Unexpected response type=$typ"; head -n 5 "$RESP"; break; }

            jq -c '.[]' "$RESP" | while read -r repo; do
              path=$(jq -r '.path // empty' <<<"$repo")
              [[ -z "$path" ]] && continue

              # Repo filters
              if ! [[ "$path" =~ $include_repo ]]; then echo "::notice::Skip repo '$path' (include)"; continue; fi
              if   [[ "$path" =~ $exclude_repo ]]; then echo "::notice::Skip repo '$path' (exclude)"; continue; fi

              # Compute GHCR image name
              if [[ "${CR_NAME_MODE:-path}" == "fullpath" ]]; then
                IMAGE_NAME="${IMG_BASE}"
              else
                sub="${path#${GL_PROJECT}}"; sub="${sub#/}"
                if [[ -n "$sub" ]]; then
                  IMAGE_NAME="${IMG_BASE}${GHCR_IMAGE_SEPARATOR:-'-'}${sub//\//${GHCR_IMAGE_SEPARATOR:-'-'}}"
                else
                  IMAGE_NAME="${IMG_BASE}"
                fi
              fi

              # Tags (array may be empty)
              mapfile -t tags < <(jq -r '.tags[].name' <<<"$repo" 2>/dev/null || true)
              if [[ "${#tags[@]}" -eq 0 ]]; then
                echo "::notice::No tags in repo '$path'"
              fi

              for tag in "${tags[@]}"; do
                if ! [[ "$tag" =~ $include_tag ]]; then echo "::notice::Skip tag '$tag' (include)"; continue; fi
                if   [[ "$tag" =~ $exclude_tag ]]; then echo "::notice::Skip tag '$tag' (exclude)"; continue; fi

                SRC="docker://${host}/${path}:${tag}"
                DST="docker://ghcr.io/${GH_OWNER}/${IMAGE_NAME}:${tag}"
                echo "Mirror: ${SRC}  →  ${DST}"

                [[ "${DRY_RUN}" == "true" ]] && continue

                skopeo copy \
                  --src-creds "oauth2:${GL_TOKEN}" \
                  --dest-creds "${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}" \
                  "${SRC}" "${DST}"
              done
            done

            next=$(awk -F': ' '/^X-Next-Page:/ {print $2}' "$HDR" | tr -d '\r')
            [[ -z "$next" || "$next" == "0" ]] && break
            page="$next"
          done

  nothing_to_do:
    name: "ℹ️ No projects found — skipping mirror"
    needs: discover_projects
    if: ${{ needs.discover_projects.outputs.project_count == '0' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo "::notice::No projects discovered under '${GL_GROUP}'. Nothing to mirror."
