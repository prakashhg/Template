
name: Pipeline Converter (GitLab CI ➜ GitHub Actions)

on:
  workflow_dispatch:
    inputs:
      mode:
        description: 'Choose: importer-audit | importer-dry-run | importer-migrate | fallback-convert'
        required: true
        default: 'importer-migrate'
      repos_file:
        description: 'Path to file with GitHub repos (owner/repo per line)'
        required: true
        default: 'repos.txt'
      base_branch:
        description: 'Base branch to target PRs (e.g., main)'
        required: true
        default: 'main'
      gitlab_server_url:
        description: 'GitLab base URL (e.g., https://gitlab.com or https://gitlab.example.com)'
        required: false
        default: 'https://gitlab.com'
      auto_merge:
        description: 'Enable auto-merge on created PRs (true/false)'
        required: true
        default: 'true'

permissions:
  contents: write        # push branches
  pull-requests: write   # create/merge PRs

jobs:
  # 1) Build matrix from repos_file
  fanout:
    runs-on: ubuntu-latest
    outputs:
      repos_json: ${{ steps.matrix.outputs.repos_json }}
    steps:
      - uses: actions/checkout@v4

      - id: matrix
        name: Build matrix from repos file
        shell: bash
        run: |
          set -euo pipefail

          FILE="${{ github.event.inputs.repos_file }}"
          if [ ! -f "$FILE" ]; then
            echo "Repos file not found: $FILE" >&2
            exit 1
          fi

          # Generate JSON array from repos.txt using python -c (no here-doc / HTML escapes)
          REPOS_JSON="$(python3 -c 'import json,sys; fp=sys.argv[1]; print(json.dumps([l.strip() for l in open(fp,"r",encoding="utf-8") if l.strip()]))' "$FILE")"

          # Expose the value to later jobs via step output
          echo "repos_json=${REPOS_JSON}" >> "$GITHUB_OUTPUT"

  # 2A) PATH A: Use GitHub Actions Importer (audit / dry-run / migrate)
  importer:
    runs-on: ubuntu-latest
    needs: [fanout]
    if: startsWith(github.event.inputs.mode, 'importer-')
    strategy:
      fail-fast: false
      matrix:
        repo: ${{ fromJson(needs.fanout.outputs.repos_json) }}
    env:
      # Your secrets:
      GH_TOKEN:            ${{ secrets.GH_TOKEN }}
      GITLAB_TOKEN:        ${{ secrets.GITLAB_TOKEN }}

      # Variables expected by the Importer and gh CLI:
      GITHUB_ACCESS_TOKEN: ${{ secrets.GH_TOKEN }}        # Importer needs this
      GITLAB_ACCESS_TOKEN: ${{ secrets.GITLAB_TOKEN }}    # Importer needs this

      # Inputs:
      GITLAB_SERVER_URL:   ${{ github.event.inputs.gitlab_server_url }}
      BASE_BRANCH:         ${{ github.event.inputs.base_branch }}
      AUTO_MERGE:          ${{ github.event.inputs.auto_merge }}

    steps:
      - name: Ensure Docker & GitHub CLI available
        shell: bash
        run: |
          set -euo pipefail
          if ! docker --version >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y docker.io
            sudo systemctl start docker || true
          fi
          docker --version
          gh --version || (echo "GitHub CLI not found" >&2; exit 1)

      - name: Install GH Actions Importer extension and update
        shell: bash
        run: |
          set -euo pipefail
          gh extension install github/gh-actions-importer || true
          gh actions-importer update

      - name: Configure Importer credentials
        shell: bash
        run: |
          set -euo pipefail
          # Provide .env.local for Importer (reads env vars when executing)
          cat > .env.local <<EOF
GITHUB_ACCESS_TOKEN=${GITHUB_ACCESS_TOKEN}
GITLAB_ACCESS_TOKEN=${GITLAB_ACCESS_TOKEN}
GITLAB_SERVER_URL=${GITLAB_SERVER_URL}
EOF

      - name: Importer — AUDIT (plan migration footprint)
        if: github.event.inputs.mode == 'importer-audit'
        shell: bash
        run: |
          set -euo pipefail
          # Produces a JSON audit report per repo
          gh actions-importer audit gitlab \
            --output "audit-${{ matrix.repo }}.json"

      - name: Importer — DRY-RUN (generate workflows without PR)
        if: github.event.inputs.mode == 'importer-dry-run'
        shell: bash
        run: |
          set -euo pipefail
          # Converts GitLab pipeline to Actions YAML (for review)
          gh actions-importer dry-run gitlab \
            --output-dir "./dryrun-${{ matrix.repo }}" \
            --target-repo "${{ matrix.repo }}"

      - name: Importer — MIGRATE (convert & open PR)
        if: github.event.inputs.mode == 'importer-migrate'
        shell: bash
        run: |
          set -euo pipefail
          # Converts pipelines and opens a PR against BASE_BRANCH
          gh actions-importer migrate gitlab \
            --target-repo "${{ matrix.repo }}" \
            --base-branch "${BASE_BRANCH}"

      - name: (Optional) Enable auto-merge on created PR
        if: github.event.inputs.mode == 'importer-migrate' && env.AUTO_MERGE == 'true'
        shell: bash
        run: |
          set -euo pipefail
          # Find the most recent open PR created by the migration and enable auto-merge
          PRN=$(gh pr list --repo "${{ matrix.repo }}" --state open --json number,createdAt --jq 'sort_by(.createdAt) | reverse | .[0].number' || true)
          if [ -n "${PRN:-}" ]; then
            gh pr merge "${PRN}" --auto --squash --delete-branch || true
          fi

  # 2B) PATH B: Fallback — detect .gitlab-ci.yml in the GitHub repo, convert, and PR
  fallback:
    runs-on: ubuntu-latest
    needs: [fanout]
    if: github.event.inputs.mode == 'fallback-convert'
    strategy:
      fail-fast: false
      matrix:
        repo: ${{ fromJson(needs.fanout.outputs.repos_json) }}
    env:
      GH_TOKEN:    ${{ secrets.GH_TOKEN }}               # for gh CLI
      BASE_BRANCH: ${{ github.event.inputs.base_branch }}
      AUTO_MERGE:  ${{ github.event.inputs.auto_merge }}

    steps:
      - name: Clone target repo
        shell: bash
        run: |
          set -euo pipefail
          gh repo clone "${{ matrix.repo }}" target -- -q
          cd target
          git config user.name  "ci-migration-bot"
          git config user.email "ci-migration-bot@users.noreply.github.com"

      - name: Detect .gitlab-ci.yml
        id: detect
        working-directory: target
        shell: bash
        run: |
          if [ -f ".gitlab-ci.yml" ]; then
            echo "found=true" >> "$GITHUB_OUTPUT"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Skip if not found
        if: steps.detect.outputs.found != 'true'
        shell: bash
        run: echo "No .gitlab-ci.yml in ${{ matrix.repo }}, skipping."

      - name: Create inline converter (basic mapping)
        if: steps.detect.outputs.found == 'true'
        working-directory: target
        shell: bash
        run: |
          cat > gitlabci_to_actions.py <<'PY'
#!/usr/bin/env python3
import os, yaml
from pathlib import Path
WORKFLOW_DIR=".github/workflows"; WORKFLOW_FILE="ci-converted.yml"

def load_yaml(p):
    return yaml.safe_load(p.read_text(encoding="utf-8")) or {}

def write_yaml(p, data):
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(yaml.safe_dump(data, sort_keys=False), encoding="utf-8")

def convert(ci):
    wf = {
        "name": "CI (converted)",
        "on": {
            "push": {"branches": ["**"]},
            "pull_request": {"branches": ["**"]},
            "workflow_dispatch": {}
        },
        "jobs": {}
    }
    stages = ci.get("stages") or []
    globals = ci.get("variables") or {}
    defaults = ci.get("default") or {}
    gk = {"stages","variables","workflow","default","include","spec"}

    jobs = [k for k,v in ci.items() if isinstance(v,dict) and k not in gk]
    stage_of = { j: ci[j].get("stage", (stages[0] if stages else "build")) for j in jobs }

    def needs_for(job):
        s = stage_of[job]
        if not stages or s not in stages: return []
        idx = stages.index(s)
        prev = set(stages[:idx])
        return [jn for jn in jobs if stage_of[jn] in prev]

    for jn in jobs:
        j = ci[jn]
        job = {}
        job["runs-on"] = "ubuntu-latest"

        image = j.get("image") or defaults.get("image")
        if image: job["container"] = image

        env = {}
        env.update(globals)
        env.update(j.get("variables") or {})
        if env: job["env"] = env

        if j.get("allow_failure"):
            job["continue-on-error"] = True

        n = needs_for(jn)
        if n: job["needs"] = n

        services = j.get("services")
        if services and isinstance(services, list):
            svc = {}
            for s in services:
                if isinstance(s, str):
                    label = s.split("/")[-1].split(":")[0].replace("-","_")
                    svc[label] = {"image": s}
            job["services"] = svc

        steps = [{"uses":"actions/checkout@v4"}]
        for c in j.get("before_script", []): steps.append({"name":"before","run":c})
        for c in j.get("script", []):        steps.append({"name":"run","run":c})
        for c in j.get("after_script", []):  steps.append({"name":"after","run":c})

        cache = j.get("cache")
        if cache and isinstance(cache, dict) and cache.get("paths"):
            steps.insert(1,{
                "name":"Cache","uses":"actions/cache@v4",
                "with":{"path":"\n".join(cache["paths"]),
                        "key":"${{ runner.os }}-cache-${{ hashFiles('**/*') }}",
                        "restore-keys":"${{ runner.os }}-cache-"} })

        arts = j.get("artifacts")
        if isinstance(arts, dict) and arts.get("paths"):
            steps.append({
                "name":"Upload artifacts","uses":"actions/upload-artifact@v4",
                "with":{"name":f"{jn}-artifacts","path":"\n".join(arts["paths"])} })

        job["steps"] = steps
        wf["jobs"][jn] = job

    return wf

root = Path(".")
ci = load_yaml(root / ".gitlab-ci.yml")
wf = convert(ci)
out = root / WORKFLOW_DIR / WORKFLOW_FILE
write_yaml(out, wf)
print(f"Wrote {out}")
PY
          chmod +x gitlabci_to_actions.py

      - name: Convert GitLab CI ➜ GitHub Actions
        if: steps.detect.outputs.found == 'true'
        working-directory: target
        shell: bash
        run: |
          set -euo pipefail
          python3 gitlabci_to_actions.py

      - name: Create migration branch, commit & push
        if: steps.detect.outputs.found == 'true'
        id: branch
        working-directory: target
        shell: bash
        run: |
          set -euo pipefail
          BR="ci-migration/$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BR"
          git add .github/workflows
          if git diff --cached --quiet; then
            echo "No changes to commit; skipping."
            echo "branch=" >> "$GITHUB_OUTPUT"; exit 0
          fi
          git commit -m "Migrate GitLab CI ➜ GitHub Actions (auto-generated)"
          git push -u origin "$BR"
          echo "branch=$BR" >> "$GITHUB_OUTPUT"

      - name: Open PR
        if: steps.detect.outputs.found == 'true' && steps.branch.outputs.branch != ''
        id: pr
        working-directory: target
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          gh pr create --base "${{ env.BASE_BRANCH }}" --head "${{ steps.branch.outputs.branch }}" \
            --title "Migrate GitLab CI ➜ GitHub Actions" \
            --body "Automated conversion of .gitlab-ci.yml to GitHub Actions workflows"

      - name: (Optional) Enable auto-merge
        if: steps.detect.outputs.found == 'true' && steps.branch.outputs.branch != '' && env.AUTO_MERGE == 'true'
        working-directory: target
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          PRN=$(gh pr list --state open --json number,createdAt --jq 'sort          PRN=$(gh pr list --state open --json number,createdAt --jq 'sort_by(.createdAt) | reverse | .[0].number' || true)
          if [ -n "${PRN:-}" ]; then
            gh pr merge "${PRN}" --auto --squash --delete-branch || true
